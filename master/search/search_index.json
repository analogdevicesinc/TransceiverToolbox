{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":".md-typeset h1, .md-content__button { display: none; } ADI maintains a set of tools to model, interface, and target with ADI transceiver devices within MATLAB and Simulink. These are combined into single Toolbox which contains a set of Board Support Packages (BSP). The list of supported boards is provided below. The following have device-specific implementations in MATLAB and Simulink. If a device has an IIO driver, MATLAB support is possible, but a device-specific MATLAB or Simulink interface may not exist yet. Evaluation Card FPGA Board Streaming Support Targeting Variants and Minimum Supported Release Pluto Yes Yes ADI (2018b) MathWorks (2017a) FMComms2/3/4 Zedboard Yes Yes ADI (2018b) MathWorks (2014b) ZC702 Yes Yes ADI (2018b) MathWorks (2014b) ZC706 Yes Yes ADI (2018b) MathWorks (2014b) ZCU102 Yes Yes ADI (2018b) MathWorks (2014b) ARRADIO Arrow SoCKit Yes No ADI (2018b) ADRV9361-Z7035 Yes Yes ADI (2018b) MathWorks (2015b) ADRV9364-Z7020 Yes Yes ADI (2018b) ADRV9371/5 ZC706 Yes Yes ADI (2018b) ZCU102 Yes Yes ADI (2018b) ZYNQ3 Yes No ADI (2018b) ADRV9002 ZCU102 Yes Yes ADI (2020a) ADRV9009/8 ZC706 Yes No ADI (2018b) ZCU102 Yes Yes ADI (2018b) ADRV9009-ZU11EG Yes No ADI (2020a)","title":"Overview"},{"location":"dev_hdl_workflow/","text":"HDL Workflow !!! warning This content is meant for developers or advanced users and is not meant for general consumption. This page discusses the HDL targeting support from the perspective of the HDL source repo and HDL-Coder itself. It is not necessary for users to understand these details but for those managing the toolbox or developers extending support to new platforms this information is valuable. This page assumes a basic understanding of MathWork's HDL Workflow Advisor (HWA) and its different steps for creating IP, creating a HDL project, and generating a bitstream. HDL Repo Preparation When the toolbox is built it will clone a specific branch of the ADI HDL repo and apply certain changes to support the IP-Core Generation HDL-Coder workflow. However, with the current flow there are minimal changes required which makes moving between release simpler. This is currently done by simply replacing certain TCL scripts within the HDL repo. Creation of the toolbox, cloning of the HDL source, and applying the necessary update is driven through a Makefile in the CI/scripts folder. The toolbox is built in source form with the build as follows: make -C CI/scripts build After the above command completes the HDL source will be in place with necessary changes. The changes primarily required of the HDL source are interceptions of the build functions (procs) to skip synthesis when building a project. This is done by inserting environmental variable checks into the adi_project_xilinx.tcl script. At build time these environmental variables are set and will prevent synthesis. This way an HDL project can be built, then handed off to HDL-Coder for IP insertion and eventual synthesis. HDL-Coder is limited to only interact with Vivado or Quartus. Therefore, it cannot leverage the makefiles as traditionally used to build HDL projects in the HDL repo. HDL-Coder and the authored scripts in the toolbox use the TCL flow normally recommended for just Windows users. This is used on all platforms (Windows and Linux) to support HDL code-generation and integration with ADI toolboxes. HDL-Coder IP Core Generation Flow The orchestration of Vivado and calling of specific TCL scripts is managed through MathWork's HWA . HWA generates HDL (Verilog is currently the only supported language) for specific Simulink blocks, calls a number of TCL scripts maintained by ADI to build a project and make room for IP, then inserts that IP and calls synthesis. This will be discussed from HWA and the generated scripts it creates. This is detailed from the scripting perspective first in the figure below: graph LR A[1. Generate Verilog From Simulink IP]-->B[2. Optional: Pre-Build Project Script]; subgraph SS[vivado_create_prj.tcl] subgraph vivado_custom_block_design.tcl B --> C[3. Build Standard Project system_project.tcl ]; C --> D[4. Prune Preprocessor Script matlab_processors.tcl ]; D --> E[5. Optional: Post-Build Project Script ]; end end E --> F[6. Insert and Connect Generate IP vivado_insert_ip.tcl ]; style B fill:#f9f,stroke:#333,stroke-width:4px style E fill:#f9f,stroke:#333,stroke-width:4px style C fill:#FF0,stroke:#333,stroke-width:4px,stroke-dasharray: 5 5 style D fill:#FF0,stroke:#333,stroke-width:4px,stroke-dasharray: 5 5 Figure 1: Details IP-Core Generation flow with Toolbox At a high-level there are six main steps, two of which are optional. From the far left stage \"Generate Verilog From Simulink IP\" occurs in Stage 3 \"HDL Code Generation\" within HWA as outlined in red below. This will create Verilog within the defined project folder and then be copied into the full HDL project later on. Figure 2: HDL Workflow Advisor IP verilog generation. Within the largest central block of the flowchart labeled vivado_create_prj.tcl are all the core steps related the HWA Step 4.1, where the reference HDL project folder is built and necessary cores and nets removed to make room for IP from Simulink generated in HWA Step 3. This stage is highlighed in the figure below. The purple boxes are optional stages that are used in certain customized examples when additional work is required to prepare a reference design. The Frequency Hopping example leverages these stages. Once the project is prepared the IP is inserted and bitstream generated, which occurs through HWA Step 4.3. Figure 3: HDL Workflow Advisor project generation step. Vivado Project Perspective Based on the flow in Figure 1, there are a three main states the HDL reference design enters from a high level. These states will be discussed more from the Vivado project perspective, specifically the data path of an FMComms2 project. Other HDL projects will be similar. The first state is just the initial creation of the standard unmodified block design. Looking at Figure 4, the three IPs show the dataflow from the interface core (axi_ad9361), through the ADC FIFO, and finally into the pack core. In orange are the data buses and valid signal highlighted. These are important since the generated IP needs to be inserted where these nets are connected. Therefore, in the second state of the design these nets are removed to make room from the new IP. Figure 4: RX path in unmodified standard reference design. Once the IP is inserted into the project by HDL-Coder it is connected to the FIFO and pack cores where the nets in Figure 4 were highlighted. The new inserted and connected IP can be see in Figure 5. Figure 5: RX path with inserted IP from HDL-Coder. The connecting of the IPs and insertion are entirely managed by HDL-Coder and through the add_io_ports function and supporting JSON port definition file . Generated TCL Scripts The following scripts outlined in the figure above have certain purposes: vivado_create_prj.tcl : This is the first TCL scripted called in Stage 4 of HWA and is responsible for setting up a standard reference design and trimming nets and IPs to make room for IP from Simulink vivado_custom_block_design.tcl : This is a carbon copy of the system_project_rxtx.tcl script and is called by vivado_create_prj.tcl . This script will call adi_make.tcl , the correct system_project.tcl file, and finally matlab_processor.tcl. It will optionally call the pre/post processor TCL scripts. vivado_insert_ip.tcl : This script is fully generated by MATLAB based on the add_io definitions in MATLAB to insert the custom IP into the prepared reference design.","title":"HDL Workflow"},{"location":"dev_hdl_workflow/#hdl-workflow","text":"!!! warning This content is meant for developers or advanced users and is not meant for general consumption. This page discusses the HDL targeting support from the perspective of the HDL source repo and HDL-Coder itself. It is not necessary for users to understand these details but for those managing the toolbox or developers extending support to new platforms this information is valuable. This page assumes a basic understanding of MathWork's HDL Workflow Advisor (HWA) and its different steps for creating IP, creating a HDL project, and generating a bitstream.","title":"HDL Workflow"},{"location":"dev_hdl_workflow/#hdl-repo-preparation","text":"When the toolbox is built it will clone a specific branch of the ADI HDL repo and apply certain changes to support the IP-Core Generation HDL-Coder workflow. However, with the current flow there are minimal changes required which makes moving between release simpler. This is currently done by simply replacing certain TCL scripts within the HDL repo. Creation of the toolbox, cloning of the HDL source, and applying the necessary update is driven through a Makefile in the CI/scripts folder. The toolbox is built in source form with the build as follows: make -C CI/scripts build After the above command completes the HDL source will be in place with necessary changes. The changes primarily required of the HDL source are interceptions of the build functions (procs) to skip synthesis when building a project. This is done by inserting environmental variable checks into the adi_project_xilinx.tcl script. At build time these environmental variables are set and will prevent synthesis. This way an HDL project can be built, then handed off to HDL-Coder for IP insertion and eventual synthesis. HDL-Coder is limited to only interact with Vivado or Quartus. Therefore, it cannot leverage the makefiles as traditionally used to build HDL projects in the HDL repo. HDL-Coder and the authored scripts in the toolbox use the TCL flow normally recommended for just Windows users. This is used on all platforms (Windows and Linux) to support HDL code-generation and integration with ADI toolboxes.","title":"HDL Repo Preparation"},{"location":"dev_hdl_workflow/#hdl-coder-ip-core-generation-flow","text":"The orchestration of Vivado and calling of specific TCL scripts is managed through MathWork's HWA . HWA generates HDL (Verilog is currently the only supported language) for specific Simulink blocks, calls a number of TCL scripts maintained by ADI to build a project and make room for IP, then inserts that IP and calls synthesis. This will be discussed from HWA and the generated scripts it creates. This is detailed from the scripting perspective first in the figure below: graph LR A[1. Generate Verilog From Simulink IP]-->B[2. Optional: Pre-Build Project Script]; subgraph SS[vivado_create_prj.tcl] subgraph vivado_custom_block_design.tcl B --> C[3. Build Standard Project system_project.tcl ]; C --> D[4. Prune Preprocessor Script matlab_processors.tcl ]; D --> E[5. Optional: Post-Build Project Script ]; end end E --> F[6. Insert and Connect Generate IP vivado_insert_ip.tcl ]; style B fill:#f9f,stroke:#333,stroke-width:4px style E fill:#f9f,stroke:#333,stroke-width:4px style C fill:#FF0,stroke:#333,stroke-width:4px,stroke-dasharray: 5 5 style D fill:#FF0,stroke:#333,stroke-width:4px,stroke-dasharray: 5 5 Figure 1: Details IP-Core Generation flow with Toolbox At a high-level there are six main steps, two of which are optional. From the far left stage \"Generate Verilog From Simulink IP\" occurs in Stage 3 \"HDL Code Generation\" within HWA as outlined in red below. This will create Verilog within the defined project folder and then be copied into the full HDL project later on. Figure 2: HDL Workflow Advisor IP verilog generation. Within the largest central block of the flowchart labeled vivado_create_prj.tcl are all the core steps related the HWA Step 4.1, where the reference HDL project folder is built and necessary cores and nets removed to make room for IP from Simulink generated in HWA Step 3. This stage is highlighed in the figure below. The purple boxes are optional stages that are used in certain customized examples when additional work is required to prepare a reference design. The Frequency Hopping example leverages these stages. Once the project is prepared the IP is inserted and bitstream generated, which occurs through HWA Step 4.3. Figure 3: HDL Workflow Advisor project generation step.","title":"HDL-Coder IP Core Generation Flow"},{"location":"dev_hdl_workflow/#vivado-project-perspective","text":"Based on the flow in Figure 1, there are a three main states the HDL reference design enters from a high level. These states will be discussed more from the Vivado project perspective, specifically the data path of an FMComms2 project. Other HDL projects will be similar. The first state is just the initial creation of the standard unmodified block design. Looking at Figure 4, the three IPs show the dataflow from the interface core (axi_ad9361), through the ADC FIFO, and finally into the pack core. In orange are the data buses and valid signal highlighted. These are important since the generated IP needs to be inserted where these nets are connected. Therefore, in the second state of the design these nets are removed to make room from the new IP. Figure 4: RX path in unmodified standard reference design. Once the IP is inserted into the project by HDL-Coder it is connected to the FIFO and pack cores where the nets in Figure 4 were highlighted. The new inserted and connected IP can be see in Figure 5. Figure 5: RX path with inserted IP from HDL-Coder. The connecting of the IPs and insertion are entirely managed by HDL-Coder and through the add_io_ports function and supporting JSON port definition file .","title":"Vivado Project Perspective"},{"location":"dev_hdl_workflow/#generated-tcl-scripts","text":"The following scripts outlined in the figure above have certain purposes: vivado_create_prj.tcl : This is the first TCL scripted called in Stage 4 of HWA and is responsible for setting up a standard reference design and trimming nets and IPs to make room for IP from Simulink vivado_custom_block_design.tcl : This is a carbon copy of the system_project_rxtx.tcl script and is called by vivado_create_prj.tcl . This script will call adi_make.tcl , the correct system_project.tcl file, and finally matlab_processor.tcl. It will optionally call the pre/post processor TCL scripts. vivado_insert_ip.tcl : This script is fully generated by MATLAB based on the add_io definitions in MATLAB to insert the custom IP into the prepared reference design.","title":"Generated TCL Scripts"},{"location":"examples/","text":"Examples Examples for streaming data and targeting FPGAs are listed within the Toolbox documentation itself. To view run the following with MATLAB: doc adi They can also be viewed on GitHub: Targeting examples Streaming examples Highlighted Demos Certain examples have full articles that discuss different applications Frequency hopping Loopback delay estimation AGC Optimization Pluto LTE App","title":"Examples"},{"location":"examples/#examples","text":"Examples for streaming data and targeting FPGAs are listed within the Toolbox documentation itself. To view run the following with MATLAB: doc adi They can also be viewed on GitHub: Targeting examples Streaming examples","title":"Examples"},{"location":"examples/#highlighted-demos","text":"Certain examples have full articles that discuss different applications Frequency hopping Loopback delay estimation AGC Optimization Pluto LTE App","title":"Highlighted Demos"},{"location":"install/","text":"Installation Dependencies The toolbox has different dependencies based on the features required. These are broken down into the base dependencies for data stream and control, and HDL code generation. The base dependencies for the toolbox requires libiio and the libiio MATLAB bindings. There are three options for this install with different required MathWorks Toolboxes: Communications Toolbox Support Package for Xilinx Zynq-Based Radio Communications Toolbox Signal Processing Toolbox\u2122 DSP System Toolbox\u2122 Communications Toolbox Support Package for Analog Devices ADALM-Pluto Radio Communications Toolbox Signal Processing Toolbox\u2122 DSP System Toolbox\u2122 libiio MATLAB Binding Standalone Installer (R2021b+) Signal Processing Toolbox\u2122 HDL Generation Support To leverage HDL-Coder and the reference designs with the toolbox requires the following components: Xilinx Vivado 2019.1 Xilinx SDK 2019.1 Simulink HDL-Coder\u2122 HDL Coder\u2122 Support Package for Xilinx Zynq Platform Transceiver Toolbox Install The Transceiver Toolbox itself can be installed either from: MATLAB's Add-On Explorer GitHub Releases page . MATLAB Versions Before installing Transceiver Toolbox check the Release Page to check for the lasted supported of MATLAB. The latest version is the one which is available in Add-on Explorer , since Add-On Explorer does not currently support hosting multiple versions. If ypu have an older release of MATLAB, download the MLTBX installer from matching release on the Release Page . Add-On Explorer Walkthrough To install the toolbox from within MATLAB using the Add-On Explorer, first launch the Explorer from MATLAB's Home tab: Search for the toolbox: Select Transceiver Toolbox from results: Select add:","title":"Installation"},{"location":"install/#installation","text":"","title":"Installation"},{"location":"install/#dependencies","text":"The toolbox has different dependencies based on the features required. These are broken down into the base dependencies for data stream and control, and HDL code generation. The base dependencies for the toolbox requires libiio and the libiio MATLAB bindings. There are three options for this install with different required MathWorks Toolboxes: Communications Toolbox Support Package for Xilinx Zynq-Based Radio Communications Toolbox Signal Processing Toolbox\u2122 DSP System Toolbox\u2122 Communications Toolbox Support Package for Analog Devices ADALM-Pluto Radio Communications Toolbox Signal Processing Toolbox\u2122 DSP System Toolbox\u2122 libiio MATLAB Binding Standalone Installer (R2021b+) Signal Processing Toolbox\u2122","title":"Dependencies"},{"location":"install/#hdl-generation-support","text":"To leverage HDL-Coder and the reference designs with the toolbox requires the following components: Xilinx Vivado 2019.1 Xilinx SDK 2019.1 Simulink HDL-Coder\u2122 HDL Coder\u2122 Support Package for Xilinx Zynq Platform","title":"HDL Generation Support"},{"location":"install/#transceiver-toolbox-install","text":"The Transceiver Toolbox itself can be installed either from: MATLAB's Add-On Explorer GitHub Releases page . MATLAB Versions Before installing Transceiver Toolbox check the Release Page to check for the lasted supported of MATLAB. The latest version is the one which is available in Add-on Explorer , since Add-On Explorer does not currently support hosting multiple versions. If ypu have an older release of MATLAB, download the MLTBX installer from matching release on the Release Page .","title":"Transceiver Toolbox Install"},{"location":"install/#add-on-explorer-walkthrough","text":"To install the toolbox from within MATLAB using the Add-On Explorer, first launch the Explorer from MATLAB's Home tab: Search for the toolbox: Select Transceiver Toolbox from results: Select add:","title":"Add-On Explorer Walkthrough"},{"location":"streaming/","text":"Receiving and Sending Data Remote data streaming to and from hardware is made available through system object interfaces , which are unique for each component or platform. The hardware interfacing system objects provide a since class to both configure a given platform and move data back and forth from the device. Command and control of hardware from MATLAB is accomplished by leveraging the IIO drivers built into the target platform's kernel and libiio which provides remote backends to control drivers across different backends. Backends can be Ethernet, serial, or USB based. Below is a diagram of the different components in the stack for an FMComms based systems, but will be nearly identical for all transceiver based systems. Since libiio is cross-platform it can be used from Windows, Linux, or macOS based systems. It is also a lower level library independent of MATLAB, so when moving toward production or untethered systems similar APIs that are used in MATLAB can be used in C,C++,Python, or other languages. Connecting and Configuration Connecting to hardware is done by setting the uri property of the system object interface. The uri for libiio always has the convention \" < backend >:< address > \", where backend can be ip,usb, or serial. address will be specific to the backend. This is documented in the libiio API . Below is a basic example of setting up an AD9361 receiver using an Ethernet/IP backend where the address of the target system is 192.168.2.1: 1 2 3 rx = adi.AD9361.Rx; rx.uri = 'ip:192.168.2.1'; data = rx(); With the code above, the hardware is not contacted until the operator or step method is called on line 3. Therefore, any properties that are set or defined before line 3 are not applied or updated on the hardware until after line 3. However, after line 3 has completed the object will become locked and certain configuration changes cannot be applied after this point. These will primarily sample rates and buffer sizes. The state of the object follows the flow of the diagram below triggered by line line 3 above. graph LR Z[Operator Called] -->A; A[Connect To Board] --> B[Update Properties]; B --> C[Initialize Buffers]; C --> D[Send or Receive Data]; D --> E[Lock Object]; Once the object becomes locked it must be released if the sample rate or buffers need to be modified. This will disconnect from the hardware: rx.release(); % Release object To provide a complete example we can do more advanced configuration like so to demonstrate property changes: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 rx = adi.AD9361.Rx; rx.uri = 'ip:192.168.2.1'; rx.SamplesPerFrame = 1024; rx.CenterFrequency = 1e9; dataLO1 = rx(); % Update tunable property rx.CenterFrequency = 2e9; dataLO2 = rx(); % Update non-tunable property rx.release(); rx.SamplesPerFrame = 4096; dataLargerBuffer = rx(); Receiving Data To receive or capture data from a given device first you must instantiate that device's interface class. For example on a AD9361 based system, this would be as follows: rx = adi.AD9361.Rx; Once instantiated you can configure the number of samples to be captured by setting the property SamplesPerFrame. rx.SamplesPerFrame = 1e6; SamplesPerFrame is the number of samples per channel which will be captured. If your device produces complex data (I and Q) this is the number of complex samples. There will be a limit to the maximum samples which can be collected. By default this is set to 2^20, but it may be possible to make it larger depending on hardware. Once the operator methods are used for a give instantiation, the object will become locked and the SamplesPerFrame property cannot be changed. This is known as a non-tunable property. To actually collect the samples or perform the capture, the operator of the system object should be used or the step method as so: data = rx(); % Operator method data = rx.step(); % Step method Both method calls are equivalent, and the produced matrix data will be of size [SamplesPerFrame x length(EnabledChannels)]. EnabledChannels determines the channels which data will be collected from. EnabledChannels is a [1xN] vector with indexes starting at 1 of the desired channels. If the device transmits or receive complex data, these indexes are for complex channel pairs. For example, the AD9361 has 2 receivers (4 ADC) and setting EnabledChannels as so will capture data from all 4 converters: rx.EnabledChannels = [1,2]; You cannot enable individual converters on complex data based devices, and the EnabledChannels property is always sorted so the channel mappings cannot be changed within the produced data. Sending Data Transmitting data is very similar to receiving it, a transmitter class needs to be instantiated to send data first. For a ADRV9009 based device this would be as follows: tx = adi.ADRV9009.Tx; Unlike the receivers, transmit objects automatically create their internal buffers based on the data passed to them during their operator or step methods. These methods can be called as follows with some data: tx_data = complex(2^15.*randn(1024,1),2^15.*randn(1024,1)); tx(tx_data); % Operator method tx.step(tx_data); % Step method However, once the step or operator method is called the object becomes locked and future passed data vectors must be the same length. As with the receive classes, the size of the passed data must be [SomeFixedSize x EnabledChannels]. EnabledChannels has the same definition as the receive side, except applied to DACs. Unlike the receiver, transmit objects have the ability to utilize cyclic buffers which will continuously transmit a provided vector without gaps forever. To utilize cyclic buffers set the EnableCyclicBuffers property then pass the operator data as follows: tx = adi.ADRV9009.Tx; tx.EnableCyclicBuffers = true; tx_data = complex(2^15.*randn(1024,1),2^15.*randn(1024,1)); tx(tx_data); % Data will repeat forever One a vector is passed to the object with EnableCyclicBuffers set to true , the object will not accept future buffers unless first release or cleared. By default the system objects will utilize DMA as the source of data for the DACs, which will use data past from the operator. This can be set manually through the DataSource properties as follows: rx.DataSource = 'DMA'; DDS Instead of providing data for transmission, it is possible to utilize DDSs inside the FPGA to send tones to individual DACs. For specific boards there are two DDS per DAC, which can be used to create complex (one-sided) tones. These DDSs can be used by first setting the DataSource property: rx.DataSource = 'DDS'; Then the scale, frequency, and phase of each DDS can be controlled through three attributes as follows: rx.DDSFrequencies = [1e3,1e3,1e3,1e3;1e4,1e4,1e4,1e4]; % Must be range [0 FS/2] rx.DDSScales = [1,1,1,1;0,0,0,0]; % Must be range [0,1] rx.DDSPhases = [0,90e3,0,90e3,0,0;0,0,0,0]; % Each in millidegrees [0,90000] Each of the above properties must be of size [2x(NumberOfPartDACs)], where each row is the first DDS of a given DAC (column) and the second row is the second DDS of a given DAC (column).","title":"Data Streaming"},{"location":"streaming/#receiving-and-sending-data","text":"Remote data streaming to and from hardware is made available through system object interfaces , which are unique for each component or platform. The hardware interfacing system objects provide a since class to both configure a given platform and move data back and forth from the device. Command and control of hardware from MATLAB is accomplished by leveraging the IIO drivers built into the target platform's kernel and libiio which provides remote backends to control drivers across different backends. Backends can be Ethernet, serial, or USB based. Below is a diagram of the different components in the stack for an FMComms based systems, but will be nearly identical for all transceiver based systems. Since libiio is cross-platform it can be used from Windows, Linux, or macOS based systems. It is also a lower level library independent of MATLAB, so when moving toward production or untethered systems similar APIs that are used in MATLAB can be used in C,C++,Python, or other languages.","title":"Receiving and Sending Data"},{"location":"streaming/#connecting-and-configuration","text":"Connecting to hardware is done by setting the uri property of the system object interface. The uri for libiio always has the convention \" < backend >:< address > \", where backend can be ip,usb, or serial. address will be specific to the backend. This is documented in the libiio API . Below is a basic example of setting up an AD9361 receiver using an Ethernet/IP backend where the address of the target system is 192.168.2.1: 1 2 3 rx = adi.AD9361.Rx; rx.uri = 'ip:192.168.2.1'; data = rx(); With the code above, the hardware is not contacted until the operator or step method is called on line 3. Therefore, any properties that are set or defined before line 3 are not applied or updated on the hardware until after line 3. However, after line 3 has completed the object will become locked and certain configuration changes cannot be applied after this point. These will primarily sample rates and buffer sizes. The state of the object follows the flow of the diagram below triggered by line line 3 above. graph LR Z[Operator Called] -->A; A[Connect To Board] --> B[Update Properties]; B --> C[Initialize Buffers]; C --> D[Send or Receive Data]; D --> E[Lock Object]; Once the object becomes locked it must be released if the sample rate or buffers need to be modified. This will disconnect from the hardware: rx.release(); % Release object To provide a complete example we can do more advanced configuration like so to demonstrate property changes: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 rx = adi.AD9361.Rx; rx.uri = 'ip:192.168.2.1'; rx.SamplesPerFrame = 1024; rx.CenterFrequency = 1e9; dataLO1 = rx(); % Update tunable property rx.CenterFrequency = 2e9; dataLO2 = rx(); % Update non-tunable property rx.release(); rx.SamplesPerFrame = 4096; dataLargerBuffer = rx();","title":"Connecting and Configuration"},{"location":"streaming/#receiving-data","text":"To receive or capture data from a given device first you must instantiate that device's interface class. For example on a AD9361 based system, this would be as follows: rx = adi.AD9361.Rx; Once instantiated you can configure the number of samples to be captured by setting the property SamplesPerFrame. rx.SamplesPerFrame = 1e6; SamplesPerFrame is the number of samples per channel which will be captured. If your device produces complex data (I and Q) this is the number of complex samples. There will be a limit to the maximum samples which can be collected. By default this is set to 2^20, but it may be possible to make it larger depending on hardware. Once the operator methods are used for a give instantiation, the object will become locked and the SamplesPerFrame property cannot be changed. This is known as a non-tunable property. To actually collect the samples or perform the capture, the operator of the system object should be used or the step method as so: data = rx(); % Operator method data = rx.step(); % Step method Both method calls are equivalent, and the produced matrix data will be of size [SamplesPerFrame x length(EnabledChannels)]. EnabledChannels determines the channels which data will be collected from. EnabledChannels is a [1xN] vector with indexes starting at 1 of the desired channels. If the device transmits or receive complex data, these indexes are for complex channel pairs. For example, the AD9361 has 2 receivers (4 ADC) and setting EnabledChannels as so will capture data from all 4 converters: rx.EnabledChannels = [1,2]; You cannot enable individual converters on complex data based devices, and the EnabledChannels property is always sorted so the channel mappings cannot be changed within the produced data.","title":"Receiving Data"},{"location":"streaming/#sending-data","text":"Transmitting data is very similar to receiving it, a transmitter class needs to be instantiated to send data first. For a ADRV9009 based device this would be as follows: tx = adi.ADRV9009.Tx; Unlike the receivers, transmit objects automatically create their internal buffers based on the data passed to them during their operator or step methods. These methods can be called as follows with some data: tx_data = complex(2^15.*randn(1024,1),2^15.*randn(1024,1)); tx(tx_data); % Operator method tx.step(tx_data); % Step method However, once the step or operator method is called the object becomes locked and future passed data vectors must be the same length. As with the receive classes, the size of the passed data must be [SomeFixedSize x EnabledChannels]. EnabledChannels has the same definition as the receive side, except applied to DACs. Unlike the receiver, transmit objects have the ability to utilize cyclic buffers which will continuously transmit a provided vector without gaps forever. To utilize cyclic buffers set the EnableCyclicBuffers property then pass the operator data as follows: tx = adi.ADRV9009.Tx; tx.EnableCyclicBuffers = true; tx_data = complex(2^15.*randn(1024,1),2^15.*randn(1024,1)); tx(tx_data); % Data will repeat forever One a vector is passed to the object with EnableCyclicBuffers set to true , the object will not accept future buffers unless first release or cleared. By default the system objects will utilize DMA as the source of data for the DACs, which will use data past from the operator. This can be set manually through the DataSource properties as follows: rx.DataSource = 'DMA';","title":"Sending Data"},{"location":"streaming/#dds","text":"Instead of providing data for transmission, it is possible to utilize DDSs inside the FPGA to send tones to individual DACs. For specific boards there are two DDS per DAC, which can be used to create complex (one-sided) tones. These DDSs can be used by first setting the DataSource property: rx.DataSource = 'DDS'; Then the scale, frequency, and phase of each DDS can be controlled through three attributes as follows: rx.DDSFrequencies = [1e3,1e3,1e3,1e3;1e4,1e4,1e4,1e4]; % Must be range [0 FS/2] rx.DDSScales = [1,1,1,1;0,0,0,0]; % Must be range [0,1] rx.DDSPhases = [0,90e3,0,90e3,0,0;0,0,0,0]; % Each in millidegrees [0,90000] Each of the above properties must be of size [2x(NumberOfPartDACs)], where each row is the first DDS of a given DAC (column) and the second row is the second DDS of a given DAC (column).","title":"DDS"},{"location":"targeting/","text":"HDL Targeting with HDL-Coder Transceiver Toolbox supports the IP Core generation flow from MathWorks which allows for automated integration of DSP into HDL reference designs from Analog Devices. This workflow will take Simulink subsystems, run HDL-Coder to generate source Verilog, and then integrate that into a larger reference design. The figure below is a simplified block diagram of a SoC (Fabric+ARM) device, where specialized IP are inserted into the receive and transmit datapaths. This is supported on specific FPGA families and transceiver based reference designs. This support is based on the Zynq HDL-Coder and support Recommended Review Getting started with Zynq Getting Started","title":"HDL Targeting"},{"location":"targeting/#hdl-targeting-with-hdl-coder","text":"Transceiver Toolbox supports the IP Core generation flow from MathWorks which allows for automated integration of DSP into HDL reference designs from Analog Devices. This workflow will take Simulink subsystems, run HDL-Coder to generate source Verilog, and then integrate that into a larger reference design. The figure below is a simplified block diagram of a SoC (Fabric+ARM) device, where specialized IP are inserted into the receive and transmit datapaths. This is supported on specific FPGA families and transceiver based reference designs. This support is based on the Zynq HDL-Coder and support","title":"HDL Targeting with HDL-Coder"},{"location":"targeting/#recommended-review","text":"Getting started with Zynq","title":"Recommended Review"},{"location":"targeting/#getting-started","text":"","title":"Getting Started"},{"location":"_pages/","text":"{% include 'header.tmpl' %} .md-typeset h1, .md-content__button { display: none; } ADI maintains a set of tools to model, interface, and target with ADI transceiver devices within MATLAB and Simulink. These are combined into single Toolbox which contains a set of Board Support Packages (BSP). The list of supported boards is provided below. The following have device-specific implementations in MATLAB and Simulink. If a device has an IIO driver, MATLAB support is possible, but a device-specific MATLAB or Simulink interface may not exist yet. Evaluation Card FPGA Board Streaming Support Targeting Variants and Minimum Supported Release Pluto Yes Yes ADI (2018b) MathWorks (2017a) FMComms2/3/4 Zedboard Yes Yes ADI (2018b) MathWorks (2014b) ZC702 Yes Yes ADI (2018b) MathWorks (2014b) ZC706 Yes Yes ADI (2018b) MathWorks (2014b) ZCU102 Yes Yes ADI (2018b) MathWorks (2014b) ARRADIO Arrow SoCKit Yes No ADI (2018b) ADRV9361-Z7035 Yes Yes ADI (2018b) MathWorks (2015b) ADRV9364-Z7020 Yes Yes ADI (2018b) ADRV9371/5 ZC706 Yes Yes ADI (2018b) ZCU102 Yes Yes ADI (2018b) ZYNQ3 Yes No ADI (2018b) ADRV9002 ZCU102 Yes Yes ADI (2020a) ADRV9009/8 ZC706 Yes No ADI (2018b) ZCU102 Yes Yes ADI (2018b) ADRV9009-ZU11EG Yes No ADI (2020a)","title":"Index"},{"location":"_pages/dev_hdl_workflow/","text":"HDL Workflow !!! warning This content is meant for developers or advanced users and is not meant for general consumption. This page discusses the HDL targeting support from the perspective of the HDL source repo and HDL-Coder itself. It is not necessary for users to understand these details but for those managing the toolbox or developers extending support to new platforms this information is valuable. This page assumes a basic understanding of MathWork's HDL Workflow Advisor (HWA) and its different steps for creating IP, creating a HDL project, and generating a bitstream. HDL Repo Preparation When the toolbox is built it will clone a specific branch of the ADI HDL repo and apply certain changes to support the IP-Core Generation HDL-Coder workflow. However, with the current flow there are minimal changes required which makes moving between release simpler. This is currently done by simply replacing certain TCL scripts within the HDL repo. Creation of the toolbox, cloning of the HDL source, and applying the necessary update is driven through a Makefile in the CI/scripts folder. The toolbox is built in source form with the build as follows: make -C CI/scripts build After the above command completes the HDL source will be in place with necessary changes. The changes primarily required of the HDL source are interceptions of the build functions (procs) to skip synthesis when building a project. This is done by inserting environmental variable checks into the adi_project_xilinx.tcl script. At build time these environmental variables are set and will prevent synthesis. This way an HDL project can be built, then handed off to HDL-Coder for IP insertion and eventual synthesis. HDL-Coder is limited to only interact with Vivado or Quartus. Therefore, it cannot leverage the makefiles as traditionally used to build HDL projects in the HDL repo. HDL-Coder and the authored scripts in the toolbox use the TCL flow normally recommended for just Windows users. This is used on all platforms (Windows and Linux) to support HDL code-generation and integration with ADI toolboxes. HDL-Coder IP Core Generation Flow The orchestration of Vivado and calling of specific TCL scripts is managed through MathWork's HWA . HWA generates HDL (Verilog is currently the only supported language) for specific Simulink blocks, calls a number of TCL scripts maintained by ADI to build a project and make room for IP, then inserts that IP and calls synthesis. This will be discussed from HWA and the generated scripts it creates. This is detailed from the scripting perspective first in the figure below: graph LR A[1. Generate Verilog From Simulink IP]-->B[2. Optional: Pre-Build Project Script]; subgraph SS[vivado_create_prj.tcl] subgraph vivado_custom_block_design.tcl B --> C[3. Build Standard Project system_project.tcl ]; C --> D[4. Prune Preprocessor Script matlab_processors.tcl ]; D --> E[5. Optional: Post-Build Project Script ]; end end E --> F[6. Insert and Connect Generate IP vivado_insert_ip.tcl ]; style B fill:#f9f,stroke:#333,stroke-width:4px style E fill:#f9f,stroke:#333,stroke-width:4px style C fill:#FF0,stroke:#333,stroke-width:4px,stroke-dasharray: 5 5 style D fill:#FF0,stroke:#333,stroke-width:4px,stroke-dasharray: 5 5 Figure 1: Details IP-Core Generation flow with Toolbox At a high-level there are six main steps, two of which are optional. From the far left stage \"Generate Verilog From Simulink IP\" occurs in Stage 3 \"HDL Code Generation\" within HWA as outlined in red below. This will create Verilog within the defined project folder and then be copied into the full HDL project later on. Figure 2: HDL Workflow Advisor IP verilog generation. Within the largest central block of the flowchart labeled vivado_create_prj.tcl are all the core steps related the HWA Step 4.1, where the reference HDL project folder is built and necessary cores and nets removed to make room for IP from Simulink generated in HWA Step 3. This stage is highlighed in the figure below. The purple boxes are optional stages that are used in certain customized examples when additional work is required to prepare a reference design. The Frequency Hopping example leverages these stages. Once the project is prepared the IP is inserted and bitstream generated, which occurs through HWA Step 4.3. Figure 3: HDL Workflow Advisor project generation step. Vivado Project Perspective Based on the flow in Figure 1, there are a three main states the HDL reference design enters from a high level. These states will be discussed more from the Vivado project perspective, specifically the data path of an FMComms2 project. Other HDL projects will be similar. The first state is just the initial creation of the standard unmodified block design. Looking at Figure 4, the three IPs show the dataflow from the interface core (axi_ad9361), through the ADC FIFO, and finally into the pack core. In orange are the data buses and valid signal highlighted. These are important since the generated IP needs to be inserted where these nets are connected. Therefore, in the second state of the design these nets are removed to make room from the new IP. Figure 4: RX path in unmodified standard reference design. Once the IP is inserted into the project by HDL-Coder it is connected to the FIFO and pack cores where the nets in Figure 4 were highlighted. The new inserted and connected IP can be see in Figure 5. Figure 5: RX path with inserted IP from HDL-Coder. The connecting of the IPs and insertion are entirely managed by HDL-Coder and through the add_io_ports function and supporting JSON port definition file . Generated TCL Scripts The following scripts outlined in the figure above have certain purposes: vivado_create_prj.tcl : This is the first TCL scripted called in Stage 4 of HWA and is responsible for setting up a standard reference design and trimming nets and IPs to make room for IP from Simulink vivado_custom_block_design.tcl : This is a carbon copy of the system_project_rxtx.tcl script and is called by vivado_create_prj.tcl . This script will call adi_make.tcl , the correct system_project.tcl file, and finally matlab_processor.tcl. It will optionally call the pre/post processor TCL scripts. vivado_insert_ip.tcl : This script is fully generated by MATLAB based on the add_io definitions in MATLAB to insert the custom IP into the prepared reference design.","title":"HDL Workflow"},{"location":"_pages/dev_hdl_workflow/#hdl-workflow","text":"!!! warning This content is meant for developers or advanced users and is not meant for general consumption. This page discusses the HDL targeting support from the perspective of the HDL source repo and HDL-Coder itself. It is not necessary for users to understand these details but for those managing the toolbox or developers extending support to new platforms this information is valuable. This page assumes a basic understanding of MathWork's HDL Workflow Advisor (HWA) and its different steps for creating IP, creating a HDL project, and generating a bitstream.","title":"HDL Workflow"},{"location":"_pages/dev_hdl_workflow/#hdl-repo-preparation","text":"When the toolbox is built it will clone a specific branch of the ADI HDL repo and apply certain changes to support the IP-Core Generation HDL-Coder workflow. However, with the current flow there are minimal changes required which makes moving between release simpler. This is currently done by simply replacing certain TCL scripts within the HDL repo. Creation of the toolbox, cloning of the HDL source, and applying the necessary update is driven through a Makefile in the CI/scripts folder. The toolbox is built in source form with the build as follows: make -C CI/scripts build After the above command completes the HDL source will be in place with necessary changes. The changes primarily required of the HDL source are interceptions of the build functions (procs) to skip synthesis when building a project. This is done by inserting environmental variable checks into the adi_project_xilinx.tcl script. At build time these environmental variables are set and will prevent synthesis. This way an HDL project can be built, then handed off to HDL-Coder for IP insertion and eventual synthesis. HDL-Coder is limited to only interact with Vivado or Quartus. Therefore, it cannot leverage the makefiles as traditionally used to build HDL projects in the HDL repo. HDL-Coder and the authored scripts in the toolbox use the TCL flow normally recommended for just Windows users. This is used on all platforms (Windows and Linux) to support HDL code-generation and integration with ADI toolboxes.","title":"HDL Repo Preparation"},{"location":"_pages/dev_hdl_workflow/#hdl-coder-ip-core-generation-flow","text":"The orchestration of Vivado and calling of specific TCL scripts is managed through MathWork's HWA . HWA generates HDL (Verilog is currently the only supported language) for specific Simulink blocks, calls a number of TCL scripts maintained by ADI to build a project and make room for IP, then inserts that IP and calls synthesis. This will be discussed from HWA and the generated scripts it creates. This is detailed from the scripting perspective first in the figure below: graph LR A[1. Generate Verilog From Simulink IP]-->B[2. Optional: Pre-Build Project Script]; subgraph SS[vivado_create_prj.tcl] subgraph vivado_custom_block_design.tcl B --> C[3. Build Standard Project system_project.tcl ]; C --> D[4. Prune Preprocessor Script matlab_processors.tcl ]; D --> E[5. Optional: Post-Build Project Script ]; end end E --> F[6. Insert and Connect Generate IP vivado_insert_ip.tcl ]; style B fill:#f9f,stroke:#333,stroke-width:4px style E fill:#f9f,stroke:#333,stroke-width:4px style C fill:#FF0,stroke:#333,stroke-width:4px,stroke-dasharray: 5 5 style D fill:#FF0,stroke:#333,stroke-width:4px,stroke-dasharray: 5 5 Figure 1: Details IP-Core Generation flow with Toolbox At a high-level there are six main steps, two of which are optional. From the far left stage \"Generate Verilog From Simulink IP\" occurs in Stage 3 \"HDL Code Generation\" within HWA as outlined in red below. This will create Verilog within the defined project folder and then be copied into the full HDL project later on. Figure 2: HDL Workflow Advisor IP verilog generation. Within the largest central block of the flowchart labeled vivado_create_prj.tcl are all the core steps related the HWA Step 4.1, where the reference HDL project folder is built and necessary cores and nets removed to make room for IP from Simulink generated in HWA Step 3. This stage is highlighed in the figure below. The purple boxes are optional stages that are used in certain customized examples when additional work is required to prepare a reference design. The Frequency Hopping example leverages these stages. Once the project is prepared the IP is inserted and bitstream generated, which occurs through HWA Step 4.3. Figure 3: HDL Workflow Advisor project generation step.","title":"HDL-Coder IP Core Generation Flow"},{"location":"_pages/dev_hdl_workflow/#vivado-project-perspective","text":"Based on the flow in Figure 1, there are a three main states the HDL reference design enters from a high level. These states will be discussed more from the Vivado project perspective, specifically the data path of an FMComms2 project. Other HDL projects will be similar. The first state is just the initial creation of the standard unmodified block design. Looking at Figure 4, the three IPs show the dataflow from the interface core (axi_ad9361), through the ADC FIFO, and finally into the pack core. In orange are the data buses and valid signal highlighted. These are important since the generated IP needs to be inserted where these nets are connected. Therefore, in the second state of the design these nets are removed to make room from the new IP. Figure 4: RX path in unmodified standard reference design. Once the IP is inserted into the project by HDL-Coder it is connected to the FIFO and pack cores where the nets in Figure 4 were highlighted. The new inserted and connected IP can be see in Figure 5. Figure 5: RX path with inserted IP from HDL-Coder. The connecting of the IPs and insertion are entirely managed by HDL-Coder and through the add_io_ports function and supporting JSON port definition file .","title":"Vivado Project Perspective"},{"location":"_pages/dev_hdl_workflow/#generated-tcl-scripts","text":"The following scripts outlined in the figure above have certain purposes: vivado_create_prj.tcl : This is the first TCL scripted called in Stage 4 of HWA and is responsible for setting up a standard reference design and trimming nets and IPs to make room for IP from Simulink vivado_custom_block_design.tcl : This is a carbon copy of the system_project_rxtx.tcl script and is called by vivado_create_prj.tcl . This script will call adi_make.tcl , the correct system_project.tcl file, and finally matlab_processor.tcl. It will optionally call the pre/post processor TCL scripts. vivado_insert_ip.tcl : This script is fully generated by MATLAB based on the add_io definitions in MATLAB to insert the custom IP into the prepared reference design.","title":"Generated TCL Scripts"},{"location":"_pages/examples/","text":"{% include 'header.tmpl' %} Examples Examples for streaming data and targeting FPGAs are listed within the Toolbox documentation itself. To view run the following with MATLAB: doc adi They can also be viewed on GitHub: Targeting examples Streaming examples Highlighted Demos Certain examples have full articles that discuss different applications Frequency hopping Loopback delay estimation AGC Optimization Pluto LTE App","title":"Examples"},{"location":"_pages/examples/#examples","text":"Examples for streaming data and targeting FPGAs are listed within the Toolbox documentation itself. To view run the following with MATLAB: doc adi They can also be viewed on GitHub: Targeting examples Streaming examples","title":"Examples"},{"location":"_pages/examples/#highlighted-demos","text":"Certain examples have full articles that discuss different applications Frequency hopping Loopback delay estimation AGC Optimization Pluto LTE App","title":"Highlighted Demos"},{"location":"_pages/install/","text":"{% include 'header.tmpl' %} Installation Dependencies The toolbox has different dependencies based on the features required. These are broken down into the base dependencies for data stream and control, and HDL code generation. The base dependencies for the toolbox requires libiio and the libiio MATLAB bindings. There are three options for this install with different required MathWorks Toolboxes: Communications Toolbox Support Package for Xilinx Zynq-Based Radio Communications Toolbox Signal Processing Toolbox\u2122 DSP System Toolbox\u2122 Communications Toolbox Support Package for Analog Devices ADALM-Pluto Radio Communications Toolbox Signal Processing Toolbox\u2122 DSP System Toolbox\u2122 libiio MATLAB Binding Standalone Installer (R2021b+) Signal Processing Toolbox\u2122 HDL Generation Support To leverage HDL-Coder and the reference designs with the toolbox requires the following components: Xilinx Vivado 2019.1 Xilinx SDK 2019.1 Simulink HDL-Coder\u2122 HDL Coder\u2122 Support Package for Xilinx Zynq Platform Transceiver Toolbox Install The Transceiver Toolbox itself can be installed either from: MATLAB's Add-On Explorer GitHub Releases page . MATLAB Versions Before installing Transceiver Toolbox check the Release Page to check for the lasted supported of MATLAB. The latest version is the one which is available in Add-on Explorer , since Add-On Explorer does not currently support hosting multiple versions. If ypu have an older release of MATLAB, download the MLTBX installer from matching release on the Release Page . Add-On Explorer Walkthrough To install the toolbox from within MATLAB using the Add-On Explorer, first launch the Explorer from MATLAB's Home tab: Search for the toolbox: Select Transceiver Toolbox from results: Select add:","title":"Install"},{"location":"_pages/install/#installation","text":"","title":"Installation"},{"location":"_pages/install/#dependencies","text":"The toolbox has different dependencies based on the features required. These are broken down into the base dependencies for data stream and control, and HDL code generation. The base dependencies for the toolbox requires libiio and the libiio MATLAB bindings. There are three options for this install with different required MathWorks Toolboxes: Communications Toolbox Support Package for Xilinx Zynq-Based Radio Communications Toolbox Signal Processing Toolbox\u2122 DSP System Toolbox\u2122 Communications Toolbox Support Package for Analog Devices ADALM-Pluto Radio Communications Toolbox Signal Processing Toolbox\u2122 DSP System Toolbox\u2122 libiio MATLAB Binding Standalone Installer (R2021b+) Signal Processing Toolbox\u2122","title":"Dependencies"},{"location":"_pages/install/#hdl-generation-support","text":"To leverage HDL-Coder and the reference designs with the toolbox requires the following components: Xilinx Vivado 2019.1 Xilinx SDK 2019.1 Simulink HDL-Coder\u2122 HDL Coder\u2122 Support Package for Xilinx Zynq Platform","title":"HDL Generation Support"},{"location":"_pages/install/#transceiver-toolbox-install","text":"The Transceiver Toolbox itself can be installed either from: MATLAB's Add-On Explorer GitHub Releases page . MATLAB Versions Before installing Transceiver Toolbox check the Release Page to check for the lasted supported of MATLAB. The latest version is the one which is available in Add-on Explorer , since Add-On Explorer does not currently support hosting multiple versions. If ypu have an older release of MATLAB, download the MLTBX installer from matching release on the Release Page .","title":"Transceiver Toolbox Install"},{"location":"_pages/install/#add-on-explorer-walkthrough","text":"To install the toolbox from within MATLAB using the Add-On Explorer, first launch the Explorer from MATLAB's Home tab: Search for the toolbox: Select Transceiver Toolbox from results: Select add:","title":"Add-On Explorer Walkthrough"},{"location":"_pages/streaming/","text":"{% include 'header.tmpl' %} Receiving and Sending Data Remote data streaming to and from hardware is made available through system object interfaces , which are unique for each component or platform. The hardware interfacing system objects provide a since class to both configure a given platform and move data back and forth from the device. Command and control of hardware from MATLAB is accomplished by leveraging the IIO drivers built into the target platform's kernel and libiio which provides remote backends to control drivers across different backends. Backends can be Ethernet, serial, or USB based. Below is a diagram of the different components in the stack for an FMComms based systems, but will be nearly identical for all transceiver based systems. Since libiio is cross-platform it can be used from Windows, Linux, or macOS based systems. It is also a lower level library independent of MATLAB, so when moving toward production or untethered systems similar APIs that are used in MATLAB can be used in C,C++,Python, or other languages. Connecting and Configuration Connecting to hardware is done by setting the uri property of the system object interface. The uri for libiio always has the convention \" < backend >:< address > \", where backend can be ip,usb, or serial. address will be specific to the backend. This is documented in the libiio API . Below is a basic example of setting up an AD9361 receiver using an Ethernet/IP backend where the address of the target system is 192.168.2.1: 1 2 3 rx = adi.AD9361.Rx; rx.uri = 'ip:192.168.2.1'; data = rx(); With the code above, the hardware is not contacted until the operator or step method is called on line 3. Therefore, any properties that are set or defined before line 3 are not applied or updated on the hardware until after line 3. However, after line 3 has completed the object will become locked and certain configuration changes cannot be applied after this point. These will primarily sample rates and buffer sizes. The state of the object follows the flow of the diagram below triggered by line line 3 above. graph LR Z[Operator Called] -->A; A[Connect To Board] --> B[Update Properties]; B --> C[Initialize Buffers]; C --> D[Send or Receive Data]; D --> E[Lock Object]; Once the object becomes locked it must be released if the sample rate or buffers need to be modified. This will disconnect from the hardware: rx.release(); % Release object To provide a complete example we can do more advanced configuration like so to demonstrate property changes: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 rx = adi.AD9361.Rx; rx.uri = 'ip:192.168.2.1'; rx.SamplesPerFrame = 1024; rx.CenterFrequency = 1e9; dataLO1 = rx(); % Update tunable property rx.CenterFrequency = 2e9; dataLO2 = rx(); % Update non-tunable property rx.release(); rx.SamplesPerFrame = 4096; dataLargerBuffer = rx(); Receiving Data To receive or capture data from a given device first you must instantiate that device's interface class. For example on a AD9361 based system, this would be as follows: rx = adi.AD9361.Rx; Once instantiated you can configure the number of samples to be captured by setting the property SamplesPerFrame. rx.SamplesPerFrame = 1e6; SamplesPerFrame is the number of samples per channel which will be captured. If your device produces complex data (I and Q) this is the number of complex samples. There will be a limit to the maximum samples which can be collected. By default this is set to 2^20, but it may be possible to make it larger depending on hardware. Once the operator methods are used for a give instantiation, the object will become locked and the SamplesPerFrame property cannot be changed. This is known as a non-tunable property. To actually collect the samples or perform the capture, the operator of the system object should be used or the step method as so: data = rx(); % Operator method data = rx.step(); % Step method Both method calls are equivalent, and the produced matrix data will be of size [SamplesPerFrame x length(EnabledChannels)]. EnabledChannels determines the channels which data will be collected from. EnabledChannels is a [1xN] vector with indexes starting at 1 of the desired channels. If the device transmits or receive complex data, these indexes are for complex channel pairs. For example, the AD9361 has 2 receivers (4 ADC) and setting EnabledChannels as so will capture data from all 4 converters: rx.EnabledChannels = [1,2]; You cannot enable individual converters on complex data based devices, and the EnabledChannels property is always sorted so the channel mappings cannot be changed within the produced data. Sending Data Transmitting data is very similar to receiving it, a transmitter class needs to be instantiated to send data first. For a ADRV9009 based device this would be as follows: tx = adi.ADRV9009.Tx; Unlike the receivers, transmit objects automatically create their internal buffers based on the data passed to them during their operator or step methods. These methods can be called as follows with some data: tx_data = complex(2^15.*randn(1024,1),2^15.*randn(1024,1)); tx(tx_data); % Operator method tx.step(tx_data); % Step method However, once the step or operator method is called the object becomes locked and future passed data vectors must be the same length. As with the receive classes, the size of the passed data must be [SomeFixedSize x EnabledChannels]. EnabledChannels has the same definition as the receive side, except applied to DACs. Unlike the receiver, transmit objects have the ability to utilize cyclic buffers which will continuously transmit a provided vector without gaps forever. To utilize cyclic buffers set the EnableCyclicBuffers property then pass the operator data as follows: tx = adi.ADRV9009.Tx; tx.EnableCyclicBuffers = true; tx_data = complex(2^15.*randn(1024,1),2^15.*randn(1024,1)); tx(tx_data); % Data will repeat forever One a vector is passed to the object with EnableCyclicBuffers set to true , the object will not accept future buffers unless first release or cleared. By default the system objects will utilize DMA as the source of data for the DACs, which will use data past from the operator. This can be set manually through the DataSource properties as follows: rx.DataSource = 'DMA'; DDS Instead of providing data for transmission, it is possible to utilize DDSs inside the FPGA to send tones to individual DACs. For specific boards there are two DDS per DAC, which can be used to create complex (one-sided) tones. These DDSs can be used by first setting the DataSource property: rx.DataSource = 'DDS'; Then the scale, frequency, and phase of each DDS can be controlled through three attributes as follows: rx.DDSFrequencies = [1e3,1e3,1e3,1e3;1e4,1e4,1e4,1e4]; % Must be range [0 FS/2] rx.DDSScales = [1,1,1,1;0,0,0,0]; % Must be range [0,1] rx.DDSPhases = [0,90e3,0,90e3,0,0;0,0,0,0]; % Each in millidegrees [0,90000] Each of the above properties must be of size [2x(NumberOfPartDACs)], where each row is the first DDS of a given DAC (column) and the second row is the second DDS of a given DAC (column).","title":"Streaming"},{"location":"_pages/streaming/#receiving-and-sending-data","text":"Remote data streaming to and from hardware is made available through system object interfaces , which are unique for each component or platform. The hardware interfacing system objects provide a since class to both configure a given platform and move data back and forth from the device. Command and control of hardware from MATLAB is accomplished by leveraging the IIO drivers built into the target platform's kernel and libiio which provides remote backends to control drivers across different backends. Backends can be Ethernet, serial, or USB based. Below is a diagram of the different components in the stack for an FMComms based systems, but will be nearly identical for all transceiver based systems. Since libiio is cross-platform it can be used from Windows, Linux, or macOS based systems. It is also a lower level library independent of MATLAB, so when moving toward production or untethered systems similar APIs that are used in MATLAB can be used in C,C++,Python, or other languages.","title":"Receiving and Sending Data"},{"location":"_pages/streaming/#connecting-and-configuration","text":"Connecting to hardware is done by setting the uri property of the system object interface. The uri for libiio always has the convention \" < backend >:< address > \", where backend can be ip,usb, or serial. address will be specific to the backend. This is documented in the libiio API . Below is a basic example of setting up an AD9361 receiver using an Ethernet/IP backend where the address of the target system is 192.168.2.1: 1 2 3 rx = adi.AD9361.Rx; rx.uri = 'ip:192.168.2.1'; data = rx(); With the code above, the hardware is not contacted until the operator or step method is called on line 3. Therefore, any properties that are set or defined before line 3 are not applied or updated on the hardware until after line 3. However, after line 3 has completed the object will become locked and certain configuration changes cannot be applied after this point. These will primarily sample rates and buffer sizes. The state of the object follows the flow of the diagram below triggered by line line 3 above. graph LR Z[Operator Called] -->A; A[Connect To Board] --> B[Update Properties]; B --> C[Initialize Buffers]; C --> D[Send or Receive Data]; D --> E[Lock Object]; Once the object becomes locked it must be released if the sample rate or buffers need to be modified. This will disconnect from the hardware: rx.release(); % Release object To provide a complete example we can do more advanced configuration like so to demonstrate property changes: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 rx = adi.AD9361.Rx; rx.uri = 'ip:192.168.2.1'; rx.SamplesPerFrame = 1024; rx.CenterFrequency = 1e9; dataLO1 = rx(); % Update tunable property rx.CenterFrequency = 2e9; dataLO2 = rx(); % Update non-tunable property rx.release(); rx.SamplesPerFrame = 4096; dataLargerBuffer = rx();","title":"Connecting and Configuration"},{"location":"_pages/streaming/#receiving-data","text":"To receive or capture data from a given device first you must instantiate that device's interface class. For example on a AD9361 based system, this would be as follows: rx = adi.AD9361.Rx; Once instantiated you can configure the number of samples to be captured by setting the property SamplesPerFrame. rx.SamplesPerFrame = 1e6; SamplesPerFrame is the number of samples per channel which will be captured. If your device produces complex data (I and Q) this is the number of complex samples. There will be a limit to the maximum samples which can be collected. By default this is set to 2^20, but it may be possible to make it larger depending on hardware. Once the operator methods are used for a give instantiation, the object will become locked and the SamplesPerFrame property cannot be changed. This is known as a non-tunable property. To actually collect the samples or perform the capture, the operator of the system object should be used or the step method as so: data = rx(); % Operator method data = rx.step(); % Step method Both method calls are equivalent, and the produced matrix data will be of size [SamplesPerFrame x length(EnabledChannels)]. EnabledChannels determines the channels which data will be collected from. EnabledChannels is a [1xN] vector with indexes starting at 1 of the desired channels. If the device transmits or receive complex data, these indexes are for complex channel pairs. For example, the AD9361 has 2 receivers (4 ADC) and setting EnabledChannels as so will capture data from all 4 converters: rx.EnabledChannels = [1,2]; You cannot enable individual converters on complex data based devices, and the EnabledChannels property is always sorted so the channel mappings cannot be changed within the produced data.","title":"Receiving Data"},{"location":"_pages/streaming/#sending-data","text":"Transmitting data is very similar to receiving it, a transmitter class needs to be instantiated to send data first. For a ADRV9009 based device this would be as follows: tx = adi.ADRV9009.Tx; Unlike the receivers, transmit objects automatically create their internal buffers based on the data passed to them during their operator or step methods. These methods can be called as follows with some data: tx_data = complex(2^15.*randn(1024,1),2^15.*randn(1024,1)); tx(tx_data); % Operator method tx.step(tx_data); % Step method However, once the step or operator method is called the object becomes locked and future passed data vectors must be the same length. As with the receive classes, the size of the passed data must be [SomeFixedSize x EnabledChannels]. EnabledChannels has the same definition as the receive side, except applied to DACs. Unlike the receiver, transmit objects have the ability to utilize cyclic buffers which will continuously transmit a provided vector without gaps forever. To utilize cyclic buffers set the EnableCyclicBuffers property then pass the operator data as follows: tx = adi.ADRV9009.Tx; tx.EnableCyclicBuffers = true; tx_data = complex(2^15.*randn(1024,1),2^15.*randn(1024,1)); tx(tx_data); % Data will repeat forever One a vector is passed to the object with EnableCyclicBuffers set to true , the object will not accept future buffers unless first release or cleared. By default the system objects will utilize DMA as the source of data for the DACs, which will use data past from the operator. This can be set manually through the DataSource properties as follows: rx.DataSource = 'DMA';","title":"Sending Data"},{"location":"_pages/streaming/#dds","text":"Instead of providing data for transmission, it is possible to utilize DDSs inside the FPGA to send tones to individual DACs. For specific boards there are two DDS per DAC, which can be used to create complex (one-sided) tones. These DDSs can be used by first setting the DataSource property: rx.DataSource = 'DDS'; Then the scale, frequency, and phase of each DDS can be controlled through three attributes as follows: rx.DDSFrequencies = [1e3,1e3,1e3,1e3;1e4,1e4,1e4,1e4]; % Must be range [0 FS/2] rx.DDSScales = [1,1,1,1;0,0,0,0]; % Must be range [0,1] rx.DDSPhases = [0,90e3,0,90e3,0,0;0,0,0,0]; % Each in millidegrees [0,90000] Each of the above properties must be of size [2x(NumberOfPartDACs)], where each row is the first DDS of a given DAC (column) and the second row is the second DDS of a given DAC (column).","title":"DDS"},{"location":"_pages/targeting/","text":"{% include 'header.tmpl' %} HDL Targeting with HDL-Coder Transceiver Toolbox supports the IP Core generation flow from MathWorks which allows for automated integration of DSP into HDL reference designs from Analog Devices. This workflow will take Simulink subsystems, run HDL-Coder to generate source Verilog, and then integrate that into a larger reference design. The figure below is a simplified block diagram of a SoC (Fabric+ARM) device, where specialized IP are inserted into the receive and transmit datapaths. This is supported on specific FPGA families and transceiver based reference designs. This support is based on the Zynq HDL-Coder and support Recommended Review Getting started with Zynq Getting Started","title":"Targeting"},{"location":"_pages/targeting/#hdl-targeting-with-hdl-coder","text":"Transceiver Toolbox supports the IP Core generation flow from MathWorks which allows for automated integration of DSP into HDL reference designs from Analog Devices. This workflow will take Simulink subsystems, run HDL-Coder to generate source Verilog, and then integrate that into a larger reference design. The figure below is a simplified block diagram of a SoC (Fabric+ARM) device, where specialized IP are inserted into the receive and transmit datapaths. This is supported on specific FPGA families and transceiver based reference designs. This support is based on the Zynq HDL-Coder and support","title":"HDL Targeting with HDL-Coder"},{"location":"_pages/targeting/#recommended-review","text":"Getting started with Zynq","title":"Recommended Review"},{"location":"_pages/targeting/#getting-started","text":"","title":"Getting Started"},{"location":"hdlrefdesigns/adrv9002/","text":"adrv9002 Reference Design Integration This page outlines the HDL reference design integration for the adrv9002 reference design for the Analog Devices ADRV9002 component. The IP-Core Generation follow is available on the based on the following base HDL reference design for the following board and design variants: Base reference design documentation Supported FPGA carriers: ZCU102 Supported design variants: RX TX RX & TX Reference Design HDL Reference Design with Custom IP from HDL-Coder. Click on sub-blocks for more documentation. The IP-Core generation flow will integrate IP generated from Simulink subsystem into an ADI authored reference design. Depending on the FPGA carrier and FMC card or SoM, this will support different IP locations based on the diagram above. HDL Worflow Advisor Port Mappings When using the HDL Worflow Advisor, the following port mappings are used to connect the reference design to the HDL-Coder generated IP-Core: Type Target Platform Interface (MATLAB) Reference Design Connection (Vivado) Width Reference Design Variant VALID-OUT IP Data Valid OUT util_adc_1_pack/fifo_wr_en 1 RX VALID-IN IP Valid Rx Data IN axi_adrv9001/adc_1_valid_i0 1 RX DATA-OUT IP Data 0 OUT util_adc_1_pack/fifo_wr_data_0 16 RX DATA-OUT IP Data 1 OUT util_adc_1_pack/fifo_wr_data_1 16 RX DATA-OUT IP Data 2 OUT util_adc_1_pack/fifo_wr_data_2 16 RX DATA-OUT IP Data 3 OUT util_adc_1_pack/fifo_wr_data_3 16 RX DATA-IN ADRV9002 ADC Data Q0 axi_adrv9001/adc_1_data_i0 16 RX DATA-IN ADRV9002 ADC Data I0 axi_adrv9001/adc_1_data_i1 16 RX DATA-IN ADRV9002 ADC Data Q0 axi_adrv9001/adc_1_data_q0 16 RX DATA-IN ADRV9002 ADC Data I0 axi_adrv9001/adc_1_data_q1 16 RX VALID-IN IP Valid Tx Data IN util_dac_1_upack/fifo_rd_valid 1 TX VALID-OUT IP Load Tx Data OUT util_dac_1_upack/fifo_rd_en 1 TX DATA-OUT ADRV9002 DAC Data Q0 axi_adrv9001/dac_1_data_i0 16 TX DATA-OUT ADRV9002 DAC Data I0 axi_adrv9001/dac_1_data_i1 16 TX DATA-OUT ADRV9002 DAC Data Q0 axi_adrv9001/dac_1_data_q0 16 TX DATA-OUT ADRV9002 DAC Data I0 axi_adrv9001/dac_1_data_q1 16 TX DATA-IN IP Data 0 IN util_dac_1_upack/fifo_rd_data_0 16 TX DATA-IN IP Data 1 IN util_dac_1_upack/fifo_rd_data_1 16 TX DATA-IN IP Data 2 IN util_dac_1_upack/fifo_rd_data_2 16 TX DATA-IN IP Data 3 IN util_dac_1_upack/fifo_rd_data_3 16 TX","title":"adrv9002"},{"location":"hdlrefdesigns/adrv9002/#adrv9002-reference-design-integration","text":"This page outlines the HDL reference design integration for the adrv9002 reference design for the Analog Devices ADRV9002 component. The IP-Core Generation follow is available on the based on the following base HDL reference design for the following board and design variants: Base reference design documentation Supported FPGA carriers: ZCU102 Supported design variants: RX TX RX & TX","title":"adrv9002 Reference Design Integration"},{"location":"hdlrefdesigns/adrv9002/#reference-design","text":"HDL Reference Design with Custom IP from HDL-Coder. Click on sub-blocks for more documentation. The IP-Core generation flow will integrate IP generated from Simulink subsystem into an ADI authored reference design. Depending on the FPGA carrier and FMC card or SoM, this will support different IP locations based on the diagram above.","title":"Reference Design"},{"location":"hdlrefdesigns/adrv9002/#hdl-worflow-advisor-port-mappings","text":"When using the HDL Worflow Advisor, the following port mappings are used to connect the reference design to the HDL-Coder generated IP-Core: Type Target Platform Interface (MATLAB) Reference Design Connection (Vivado) Width Reference Design Variant VALID-OUT IP Data Valid OUT util_adc_1_pack/fifo_wr_en 1 RX VALID-IN IP Valid Rx Data IN axi_adrv9001/adc_1_valid_i0 1 RX DATA-OUT IP Data 0 OUT util_adc_1_pack/fifo_wr_data_0 16 RX DATA-OUT IP Data 1 OUT util_adc_1_pack/fifo_wr_data_1 16 RX DATA-OUT IP Data 2 OUT util_adc_1_pack/fifo_wr_data_2 16 RX DATA-OUT IP Data 3 OUT util_adc_1_pack/fifo_wr_data_3 16 RX DATA-IN ADRV9002 ADC Data Q0 axi_adrv9001/adc_1_data_i0 16 RX DATA-IN ADRV9002 ADC Data I0 axi_adrv9001/adc_1_data_i1 16 RX DATA-IN ADRV9002 ADC Data Q0 axi_adrv9001/adc_1_data_q0 16 RX DATA-IN ADRV9002 ADC Data I0 axi_adrv9001/adc_1_data_q1 16 RX VALID-IN IP Valid Tx Data IN util_dac_1_upack/fifo_rd_valid 1 TX VALID-OUT IP Load Tx Data OUT util_dac_1_upack/fifo_rd_en 1 TX DATA-OUT ADRV9002 DAC Data Q0 axi_adrv9001/dac_1_data_i0 16 TX DATA-OUT ADRV9002 DAC Data I0 axi_adrv9001/dac_1_data_i1 16 TX DATA-OUT ADRV9002 DAC Data Q0 axi_adrv9001/dac_1_data_q0 16 TX DATA-OUT ADRV9002 DAC Data I0 axi_adrv9001/dac_1_data_q1 16 TX DATA-IN IP Data 0 IN util_dac_1_upack/fifo_rd_data_0 16 TX DATA-IN IP Data 1 IN util_dac_1_upack/fifo_rd_data_1 16 TX DATA-IN IP Data 2 IN util_dac_1_upack/fifo_rd_data_2 16 TX DATA-IN IP Data 3 IN util_dac_1_upack/fifo_rd_data_3 16 TX","title":"HDL Worflow Advisor Port Mappings"},{"location":"hdlrefdesigns/adrv9009/","text":"adrv9009 Reference Design Integration This page outlines the HDL reference design integration for the adrv9009 reference design for the Analog Devices ADRV9009 component. The IP-Core Generation follow is available on the based on the following base HDL reference design for the following board and design variants: Base reference design documentation Supported FPGA carriers: ZCU102 Supported design variants: RX TX RX & TX Reference Design HDL Reference Design with Custom IP from HDL-Coder. Click on sub-blocks for more documentation. The IP-Core generation flow will integrate IP generated from Simulink subsystem into an ADI authored reference design. Depending on the FPGA carrier and FMC card or SoM, this will support different IP locations based on the diagram above. HDL Worflow Advisor Port Mappings When using the HDL Worflow Advisor, the following port mappings are used to connect the reference design to the HDL-Coder generated IP-Core: Type Target Platform Interface (MATLAB) Reference Design Connection (Vivado) Width Reference Design Variant VALID-OUT IP Data Valid OUT util_adrv9009_rx_cpack/fifo_wr_en 1 RX VALID-IN IP Valid Rx Data IN rx_adrv9009_tpl_core/adc_valid_0 1 RX DATA-OUT IP Data 0 OUT util_adrv9009_rx_cpack/fifo_wr_data_0 16 RX DATA-OUT IP Data 1 OUT util_adrv9009_rx_cpack/fifo_wr_data_1 16 RX DATA-OUT IP Data 2 OUT util_adrv9009_rx_cpack/fifo_wr_data_2 16 RX DATA-OUT IP Data 3 OUT util_adrv9009_rx_cpack/fifo_wr_data_3 16 RX DATA-IN ADRV9009 ADC Data Q0 rx_adrv9009_tpl_core/adc_data_0 16 RX DATA-IN ADRV9009 ADC Data I0 rx_adrv9009_tpl_core/adc_data_1 16 RX DATA-IN ADRV9009 ADC Data Q1 rx_adrv9009_tpl_core/adc_data_2 16 RX DATA-IN ADRV9009 ADC Data I1 rx_adrv9009_tpl_core/adc_data_3 16 RX VALID-IN IP Valid Tx Data IN util_adrv9009_tx_upack/fifo_rd_valid 1 TX VALID-OUT IP Load Tx Data OUT util_adrv9009_tx_upack/fifo_rd_en 1 TX DATA-OUT ADRV9009 DAC Data Q0 tx_adrv9009_tpl_core/dac_data_0 16 TX DATA-OUT ADRV9009 DAC Data I0 tx_adrv9009_tpl_core/dac_data_1 16 TX DATA-OUT ADRV9009 DAC Data Q1 tx_adrv9009_tpl_core/dac_data_2 16 TX DATA-OUT ADRV9009 DAC Data I1 tx_adrv9009_tpl_core/dac_data_3 16 TX DATA-IN IP Data 0 IN util_adrv9009_tx_upack/fifo_rd_data_0 16 TX DATA-IN IP Data 1 IN util_adrv9009_tx_upack/fifo_rd_data_1 16 TX DATA-IN IP Data 2 IN util_adrv9009_tx_upack/fifo_rd_data_2 16 TX DATA-IN IP Data 3 IN util_adrv9009_tx_upack/fifo_rd_data_3 16 TX","title":"adrv9009"},{"location":"hdlrefdesigns/adrv9009/#adrv9009-reference-design-integration","text":"This page outlines the HDL reference design integration for the adrv9009 reference design for the Analog Devices ADRV9009 component. The IP-Core Generation follow is available on the based on the following base HDL reference design for the following board and design variants: Base reference design documentation Supported FPGA carriers: ZCU102 Supported design variants: RX TX RX & TX","title":"adrv9009 Reference Design Integration"},{"location":"hdlrefdesigns/adrv9009/#reference-design","text":"HDL Reference Design with Custom IP from HDL-Coder. Click on sub-blocks for more documentation. The IP-Core generation flow will integrate IP generated from Simulink subsystem into an ADI authored reference design. Depending on the FPGA carrier and FMC card or SoM, this will support different IP locations based on the diagram above.","title":"Reference Design"},{"location":"hdlrefdesigns/adrv9009/#hdl-worflow-advisor-port-mappings","text":"When using the HDL Worflow Advisor, the following port mappings are used to connect the reference design to the HDL-Coder generated IP-Core: Type Target Platform Interface (MATLAB) Reference Design Connection (Vivado) Width Reference Design Variant VALID-OUT IP Data Valid OUT util_adrv9009_rx_cpack/fifo_wr_en 1 RX VALID-IN IP Valid Rx Data IN rx_adrv9009_tpl_core/adc_valid_0 1 RX DATA-OUT IP Data 0 OUT util_adrv9009_rx_cpack/fifo_wr_data_0 16 RX DATA-OUT IP Data 1 OUT util_adrv9009_rx_cpack/fifo_wr_data_1 16 RX DATA-OUT IP Data 2 OUT util_adrv9009_rx_cpack/fifo_wr_data_2 16 RX DATA-OUT IP Data 3 OUT util_adrv9009_rx_cpack/fifo_wr_data_3 16 RX DATA-IN ADRV9009 ADC Data Q0 rx_adrv9009_tpl_core/adc_data_0 16 RX DATA-IN ADRV9009 ADC Data I0 rx_adrv9009_tpl_core/adc_data_1 16 RX DATA-IN ADRV9009 ADC Data Q1 rx_adrv9009_tpl_core/adc_data_2 16 RX DATA-IN ADRV9009 ADC Data I1 rx_adrv9009_tpl_core/adc_data_3 16 RX VALID-IN IP Valid Tx Data IN util_adrv9009_tx_upack/fifo_rd_valid 1 TX VALID-OUT IP Load Tx Data OUT util_adrv9009_tx_upack/fifo_rd_en 1 TX DATA-OUT ADRV9009 DAC Data Q0 tx_adrv9009_tpl_core/dac_data_0 16 TX DATA-OUT ADRV9009 DAC Data I0 tx_adrv9009_tpl_core/dac_data_1 16 TX DATA-OUT ADRV9009 DAC Data Q1 tx_adrv9009_tpl_core/dac_data_2 16 TX DATA-OUT ADRV9009 DAC Data I1 tx_adrv9009_tpl_core/dac_data_3 16 TX DATA-IN IP Data 0 IN util_adrv9009_tx_upack/fifo_rd_data_0 16 TX DATA-IN IP Data 1 IN util_adrv9009_tx_upack/fifo_rd_data_1 16 TX DATA-IN IP Data 2 IN util_adrv9009_tx_upack/fifo_rd_data_2 16 TX DATA-IN IP Data 3 IN util_adrv9009_tx_upack/fifo_rd_data_3 16 TX","title":"HDL Worflow Advisor Port Mappings"},{"location":"hdlrefdesigns/adrv9361z7035/","text":"adrv9361z7035 Reference Design Integration This page outlines the HDL reference design integration for the adrv9361z7035 reference design for the Analog Devices AD9361 component. The IP-Core Generation follow is available on the based on the following base HDL reference design for the following board and design variants: Base reference design documentation Supported FPGA carriers: CCBOB_CMOS CCBOB_LVDS CCBOX_LVDS CCFMC_LVDS CCPACKRF_LVDS Supported design variants: RX TX RX & TX Reference Design HDL Reference Design with Custom IP from HDL-Coder. Click on sub-blocks for more documentation. The IP-Core generation flow will integrate IP generated from Simulink subsystem into an ADI authored reference design. Depending on the FPGA carrier and FMC card or SoM, this will support different IP locations based on the diagram above. HDL Worflow Advisor Port Mappings When using the HDL Worflow Advisor, the following port mappings are used to connect the reference design to the HDL-Coder generated IP-Core: Type Target Platform Interface (MATLAB) Reference Design Connection (Vivado) Width Reference Design Variant VALID-OUT IP Data Valid OUT util_ad9361_adc_pack/fifo_wr_en 1 RX VALID-IN IP Valid Rx Data IN util_ad9361_adc_fifo/dout_valid_0 1 RX DATA-OUT IP Data 0 OUT util_ad9361_adc_pack/fifo_wr_data_0 16 RX DATA-OUT IP Data 1 OUT util_ad9361_adc_pack/fifo_wr_data_1 16 RX DATA-OUT IP Data 2 OUT util_ad9361_adc_pack/fifo_wr_data_2 16 RX DATA-OUT IP Data 3 OUT util_ad9361_adc_pack/fifo_wr_data_3 16 RX DATA-IN AD9361 ADC Data Q0 util_ad9361_adc_fifo/dout_data_0 16 RX DATA-IN AD9361 ADC Data I0 util_ad9361_adc_fifo/dout_data_1 16 RX DATA-IN AD9361 ADC Data Q1 util_ad9361_adc_fifo/dout_data_2 16 RX DATA-IN AD9361 ADC Data I1 util_ad9361_adc_fifo/dout_data_3 16 RX VALID-IN IP Valid Tx Data IN util_ad9361_dac_upack/fifo_rd_valid 1 TX VALID-OUT IP Load Tx Data OUT axi_ad9361_dac_fifo/din_valid_in_0 1 TX DATA-OUT AD9361 DAC Data Q0 axi_ad9361_dac_fifo/din_data_0 16 TX DATA-OUT AD9361 DAC Data I0 axi_ad9361_dac_fifo/din_data_1 16 TX DATA-OUT AD9361 DAC Data Q1 axi_ad9361_dac_fifo/din_data_2 16 TX DATA-OUT AD9361 DAC Data I1 axi_ad9361_dac_fifo/din_data_3 16 TX DATA-IN IP Data 0 IN util_ad9361_dac_upack/fifo_rd_data_0 16 TX DATA-IN IP Data 1 IN util_ad9361_dac_upack/fifo_rd_data_1 16 TX DATA-IN IP Data 2 IN util_ad9361_dac_upack/fifo_rd_data_2 16 TX DATA-IN IP Data 3 IN util_ad9361_dac_upack/fifo_rd_data_3 16 TX","title":"adrv9361z7035"},{"location":"hdlrefdesigns/adrv9361z7035/#adrv9361z7035-reference-design-integration","text":"This page outlines the HDL reference design integration for the adrv9361z7035 reference design for the Analog Devices AD9361 component. The IP-Core Generation follow is available on the based on the following base HDL reference design for the following board and design variants: Base reference design documentation Supported FPGA carriers: CCBOB_CMOS CCBOB_LVDS CCBOX_LVDS CCFMC_LVDS CCPACKRF_LVDS Supported design variants: RX TX RX & TX","title":"adrv9361z7035 Reference Design Integration"},{"location":"hdlrefdesigns/adrv9361z7035/#reference-design","text":"HDL Reference Design with Custom IP from HDL-Coder. Click on sub-blocks for more documentation. The IP-Core generation flow will integrate IP generated from Simulink subsystem into an ADI authored reference design. Depending on the FPGA carrier and FMC card or SoM, this will support different IP locations based on the diagram above.","title":"Reference Design"},{"location":"hdlrefdesigns/adrv9361z7035/#hdl-worflow-advisor-port-mappings","text":"When using the HDL Worflow Advisor, the following port mappings are used to connect the reference design to the HDL-Coder generated IP-Core: Type Target Platform Interface (MATLAB) Reference Design Connection (Vivado) Width Reference Design Variant VALID-OUT IP Data Valid OUT util_ad9361_adc_pack/fifo_wr_en 1 RX VALID-IN IP Valid Rx Data IN util_ad9361_adc_fifo/dout_valid_0 1 RX DATA-OUT IP Data 0 OUT util_ad9361_adc_pack/fifo_wr_data_0 16 RX DATA-OUT IP Data 1 OUT util_ad9361_adc_pack/fifo_wr_data_1 16 RX DATA-OUT IP Data 2 OUT util_ad9361_adc_pack/fifo_wr_data_2 16 RX DATA-OUT IP Data 3 OUT util_ad9361_adc_pack/fifo_wr_data_3 16 RX DATA-IN AD9361 ADC Data Q0 util_ad9361_adc_fifo/dout_data_0 16 RX DATA-IN AD9361 ADC Data I0 util_ad9361_adc_fifo/dout_data_1 16 RX DATA-IN AD9361 ADC Data Q1 util_ad9361_adc_fifo/dout_data_2 16 RX DATA-IN AD9361 ADC Data I1 util_ad9361_adc_fifo/dout_data_3 16 RX VALID-IN IP Valid Tx Data IN util_ad9361_dac_upack/fifo_rd_valid 1 TX VALID-OUT IP Load Tx Data OUT axi_ad9361_dac_fifo/din_valid_in_0 1 TX DATA-OUT AD9361 DAC Data Q0 axi_ad9361_dac_fifo/din_data_0 16 TX DATA-OUT AD9361 DAC Data I0 axi_ad9361_dac_fifo/din_data_1 16 TX DATA-OUT AD9361 DAC Data Q1 axi_ad9361_dac_fifo/din_data_2 16 TX DATA-OUT AD9361 DAC Data I1 axi_ad9361_dac_fifo/din_data_3 16 TX DATA-IN IP Data 0 IN util_ad9361_dac_upack/fifo_rd_data_0 16 TX DATA-IN IP Data 1 IN util_ad9361_dac_upack/fifo_rd_data_1 16 TX DATA-IN IP Data 2 IN util_ad9361_dac_upack/fifo_rd_data_2 16 TX DATA-IN IP Data 3 IN util_ad9361_dac_upack/fifo_rd_data_3 16 TX","title":"HDL Worflow Advisor Port Mappings"},{"location":"hdlrefdesigns/adrv9364z7020/","text":"adrv9364z7020 Reference Design Integration This page outlines the HDL reference design integration for the adrv9364z7020 reference design for the Analog Devices AD9364 component. The IP-Core Generation follow is available on the based on the following base HDL reference design for the following board and design variants: Base reference design documentation Supported FPGA carriers: CCBOB_CMOS CCBOB_LVDS CCBOX_LVDS Supported design variants: RX TX RX & TX Reference Design HDL Reference Design with Custom IP from HDL-Coder. Click on sub-blocks for more documentation. The IP-Core generation flow will integrate IP generated from Simulink subsystem into an ADI authored reference design. Depending on the FPGA carrier and FMC card or SoM, this will support different IP locations based on the diagram above. HDL Worflow Advisor Port Mappings When using the HDL Worflow Advisor, the following port mappings are used to connect the reference design to the HDL-Coder generated IP-Core: Type Target Platform Interface (MATLAB) Reference Design Connection (Vivado) Width Reference Design Variant VALID-OUT IP Data Valid OUT util_ad9361_adc_pack/fifo_wr_en 1 RX VALID-IN IP Valid Rx Data IN util_ad9361_adc_fifo/dout_valid_0 1 RX DATA-OUT IP Data 0 OUT util_ad9361_adc_pack/fifo_wr_data_0 16 RX DATA-OUT IP Data 1 OUT util_ad9361_adc_pack/fifo_wr_data_1 16 RX DATA-OUT IP Data 2 OUT util_ad9361_adc_pack/fifo_wr_data_2 16 RX DATA-OUT IP Data 3 OUT util_ad9361_adc_pack/fifo_wr_data_3 16 RX DATA-IN AD9364 ADC Data Q0 util_ad9361_adc_fifo/dout_data_0 16 RX DATA-IN AD9364 ADC Data I0 util_ad9361_adc_fifo/dout_data_1 16 RX DATA-IN AD9364 ADC Data Q1 util_ad9361_adc_fifo/dout_data_2 16 RX DATA-IN AD9364 ADC Data I1 util_ad9361_adc_fifo/dout_data_3 16 RX VALID-IN IP Valid Tx Data IN util_ad9361_dac_upack/fifo_rd_valid 1 TX VALID-OUT IP Load Tx Data OUT axi_ad9361_dac_fifo/din_valid_in_0 1 TX DATA-OUT AD9364 DAC Data Q0 axi_ad9361_dac_fifo/din_data_0 16 TX DATA-OUT AD9364 DAC Data I0 axi_ad9361_dac_fifo/din_data_1 16 TX DATA-OUT AD9364 DAC Data Q1 axi_ad9361_dac_fifo/din_data_2 16 TX DATA-OUT AD9364 DAC Data I1 axi_ad9361_dac_fifo/din_data_3 16 TX DATA-IN IP Data 0 IN util_ad9361_dac_upack/fifo_rd_data_0 16 TX DATA-IN IP Data 1 IN util_ad9361_dac_upack/fifo_rd_data_1 16 TX DATA-IN IP Data 2 IN util_ad9361_dac_upack/fifo_rd_data_2 16 TX DATA-IN IP Data 3 IN util_ad9361_dac_upack/fifo_rd_data_3 16 TX","title":"adrv9364z7020"},{"location":"hdlrefdesigns/adrv9364z7020/#adrv9364z7020-reference-design-integration","text":"This page outlines the HDL reference design integration for the adrv9364z7020 reference design for the Analog Devices AD9364 component. The IP-Core Generation follow is available on the based on the following base HDL reference design for the following board and design variants: Base reference design documentation Supported FPGA carriers: CCBOB_CMOS CCBOB_LVDS CCBOX_LVDS Supported design variants: RX TX RX & TX","title":"adrv9364z7020 Reference Design Integration"},{"location":"hdlrefdesigns/adrv9364z7020/#reference-design","text":"HDL Reference Design with Custom IP from HDL-Coder. Click on sub-blocks for more documentation. The IP-Core generation flow will integrate IP generated from Simulink subsystem into an ADI authored reference design. Depending on the FPGA carrier and FMC card or SoM, this will support different IP locations based on the diagram above.","title":"Reference Design"},{"location":"hdlrefdesigns/adrv9364z7020/#hdl-worflow-advisor-port-mappings","text":"When using the HDL Worflow Advisor, the following port mappings are used to connect the reference design to the HDL-Coder generated IP-Core: Type Target Platform Interface (MATLAB) Reference Design Connection (Vivado) Width Reference Design Variant VALID-OUT IP Data Valid OUT util_ad9361_adc_pack/fifo_wr_en 1 RX VALID-IN IP Valid Rx Data IN util_ad9361_adc_fifo/dout_valid_0 1 RX DATA-OUT IP Data 0 OUT util_ad9361_adc_pack/fifo_wr_data_0 16 RX DATA-OUT IP Data 1 OUT util_ad9361_adc_pack/fifo_wr_data_1 16 RX DATA-OUT IP Data 2 OUT util_ad9361_adc_pack/fifo_wr_data_2 16 RX DATA-OUT IP Data 3 OUT util_ad9361_adc_pack/fifo_wr_data_3 16 RX DATA-IN AD9364 ADC Data Q0 util_ad9361_adc_fifo/dout_data_0 16 RX DATA-IN AD9364 ADC Data I0 util_ad9361_adc_fifo/dout_data_1 16 RX DATA-IN AD9364 ADC Data Q1 util_ad9361_adc_fifo/dout_data_2 16 RX DATA-IN AD9364 ADC Data I1 util_ad9361_adc_fifo/dout_data_3 16 RX VALID-IN IP Valid Tx Data IN util_ad9361_dac_upack/fifo_rd_valid 1 TX VALID-OUT IP Load Tx Data OUT axi_ad9361_dac_fifo/din_valid_in_0 1 TX DATA-OUT AD9364 DAC Data Q0 axi_ad9361_dac_fifo/din_data_0 16 TX DATA-OUT AD9364 DAC Data I0 axi_ad9361_dac_fifo/din_data_1 16 TX DATA-OUT AD9364 DAC Data Q1 axi_ad9361_dac_fifo/din_data_2 16 TX DATA-OUT AD9364 DAC Data I1 axi_ad9361_dac_fifo/din_data_3 16 TX DATA-IN IP Data 0 IN util_ad9361_dac_upack/fifo_rd_data_0 16 TX DATA-IN IP Data 1 IN util_ad9361_dac_upack/fifo_rd_data_1 16 TX DATA-IN IP Data 2 IN util_ad9361_dac_upack/fifo_rd_data_2 16 TX DATA-IN IP Data 3 IN util_ad9361_dac_upack/fifo_rd_data_3 16 TX","title":"HDL Worflow Advisor Port Mappings"},{"location":"hdlrefdesigns/adrv9371/","text":"adrv9371 Reference Design Integration This page outlines the HDL reference design integration for the adrv9371 reference design for the Analog Devices AD9371 component. The IP-Core Generation follow is available on the based on the following base HDL reference design for the following board and design variants: Base reference design documentation Supported FPGA carriers: ZC706 ZCU102 Supported design variants: RX TX Reference Design HDL Reference Design with Custom IP from HDL-Coder. Click on sub-blocks for more documentation. The IP-Core generation flow will integrate IP generated from Simulink subsystem into an ADI authored reference design. Depending on the FPGA carrier and FMC card or SoM, this will support different IP locations based on the diagram above. HDL Worflow Advisor Port Mappings When using the HDL Worflow Advisor, the following port mappings are used to connect the reference design to the HDL-Coder generated IP-Core: Type Target Platform Interface (MATLAB) Reference Design Connection (Vivado) Width Reference Design Variant VALID-OUT IP Data Valid OUT util_ad9371_rx_cpack/fifo_wr_en 1 RX VALID-IN IP Valid Rx Data IN rx_ad9371_tpl_core/adc_valid_0 1 RX DATA-OUT IP Data 0 OUT util_ad9361_adc_pack/fifo_wr_data_0 16 RX DATA-OUT IP Data 1 OUT util_ad9361_adc_pack/fifo_wr_data_1 16 RX DATA-OUT IP Data 2 OUT util_ad9361_adc_pack/fifo_wr_data_2 16 RX DATA-OUT IP Data 3 OUT util_ad9361_adc_pack/fifo_wr_data_3 16 RX DATA-IN AD9371 ADC Data Q0 rx_ad9371_tpl_core/adc_data_0 16 RX DATA-IN AD9371 ADC Data I0 rx_ad9371_tpl_core/adc_data_1 16 RX DATA-IN AD9371 ADC Data Q1 rx_ad9371_tpl_core/adc_data_2 16 RX DATA-IN AD9371 ADC Data I1 rx_ad9371_tpl_core/adc_data_3 16 RX VALID-IN IP Valid Tx Data IN util_ad9371_tx_upack/fifo_rd_valid 1 TX VALID-OUT IP Load Tx Data OUT util_ad9371_tx_upack/fifo_rd_en 1 TX DATA-OUT AD9371 DAC Data Q0 tx_ad9371_tpl_core/dac_data_0 32 TX DATA-OUT AD9371 DAC Data I0 tx_ad9371_tpl_core/dac_data_1 32 TX DATA-OUT AD9371 DAC Data Q1 tx_ad9371_tpl_core/dac_data_2 32 TX DATA-OUT AD9371 DAC Data I1 tx_ad9371_tpl_core/dac_data_3 32 TX DATA-IN IP Data 0 IN util_ad9371_tx_upack/fifo_rd_data_0 32 TX DATA-IN IP Data 1 IN util_ad9371_tx_upack/fifo_rd_data_1 32 TX DATA-IN IP Data 2 IN util_ad9371_tx_upack/fifo_rd_data_2 32 TX DATA-IN IP Data 3 IN util_ad9371_tx_upack/fifo_rd_data_3 32 TX","title":"adrv9371"},{"location":"hdlrefdesigns/adrv9371/#adrv9371-reference-design-integration","text":"This page outlines the HDL reference design integration for the adrv9371 reference design for the Analog Devices AD9371 component. The IP-Core Generation follow is available on the based on the following base HDL reference design for the following board and design variants: Base reference design documentation Supported FPGA carriers: ZC706 ZCU102 Supported design variants: RX TX","title":"adrv9371 Reference Design Integration"},{"location":"hdlrefdesigns/adrv9371/#reference-design","text":"HDL Reference Design with Custom IP from HDL-Coder. Click on sub-blocks for more documentation. The IP-Core generation flow will integrate IP generated from Simulink subsystem into an ADI authored reference design. Depending on the FPGA carrier and FMC card or SoM, this will support different IP locations based on the diagram above.","title":"Reference Design"},{"location":"hdlrefdesigns/adrv9371/#hdl-worflow-advisor-port-mappings","text":"When using the HDL Worflow Advisor, the following port mappings are used to connect the reference design to the HDL-Coder generated IP-Core: Type Target Platform Interface (MATLAB) Reference Design Connection (Vivado) Width Reference Design Variant VALID-OUT IP Data Valid OUT util_ad9371_rx_cpack/fifo_wr_en 1 RX VALID-IN IP Valid Rx Data IN rx_ad9371_tpl_core/adc_valid_0 1 RX DATA-OUT IP Data 0 OUT util_ad9361_adc_pack/fifo_wr_data_0 16 RX DATA-OUT IP Data 1 OUT util_ad9361_adc_pack/fifo_wr_data_1 16 RX DATA-OUT IP Data 2 OUT util_ad9361_adc_pack/fifo_wr_data_2 16 RX DATA-OUT IP Data 3 OUT util_ad9361_adc_pack/fifo_wr_data_3 16 RX DATA-IN AD9371 ADC Data Q0 rx_ad9371_tpl_core/adc_data_0 16 RX DATA-IN AD9371 ADC Data I0 rx_ad9371_tpl_core/adc_data_1 16 RX DATA-IN AD9371 ADC Data Q1 rx_ad9371_tpl_core/adc_data_2 16 RX DATA-IN AD9371 ADC Data I1 rx_ad9371_tpl_core/adc_data_3 16 RX VALID-IN IP Valid Tx Data IN util_ad9371_tx_upack/fifo_rd_valid 1 TX VALID-OUT IP Load Tx Data OUT util_ad9371_tx_upack/fifo_rd_en 1 TX DATA-OUT AD9371 DAC Data Q0 tx_ad9371_tpl_core/dac_data_0 32 TX DATA-OUT AD9371 DAC Data I0 tx_ad9371_tpl_core/dac_data_1 32 TX DATA-OUT AD9371 DAC Data Q1 tx_ad9371_tpl_core/dac_data_2 32 TX DATA-OUT AD9371 DAC Data I1 tx_ad9371_tpl_core/dac_data_3 32 TX DATA-IN IP Data 0 IN util_ad9371_tx_upack/fifo_rd_data_0 32 TX DATA-IN IP Data 1 IN util_ad9371_tx_upack/fifo_rd_data_1 32 TX DATA-IN IP Data 2 IN util_ad9371_tx_upack/fifo_rd_data_2 32 TX DATA-IN IP Data 3 IN util_ad9371_tx_upack/fifo_rd_data_3 32 TX","title":"HDL Worflow Advisor Port Mappings"},{"location":"hdlrefdesigns/fmcomms2/","text":"fmcomms2 Reference Design Integration This page outlines the HDL reference design integration for the fmcomms2 reference design for the Analog Devices AD9361 component. The IP-Core Generation follow is available on the based on the following base HDL reference design for the following board and design variants: Base reference design documentation Supported FPGA carriers: ZED ZC706 ZC702 Supported design variants: RX TX RX & TX Reference Design HDL Reference Design with Custom IP from HDL-Coder. Click on sub-blocks for more documentation. The IP-Core generation flow will integrate IP generated from Simulink subsystem into an ADI authored reference design. Depending on the FPGA carrier and FMC card or SoM, this will support different IP locations based on the diagram above. HDL Worflow Advisor Port Mappings When using the HDL Worflow Advisor, the following port mappings are used to connect the reference design to the HDL-Coder generated IP-Core: Type Target Platform Interface (MATLAB) Reference Design Connection (Vivado) Width Reference Design Variant VALID-OUT IP Data Valid OUT util_ad9361_adc_pack/fifo_wr_en 1 RX VALID-IN IP Valid Rx Data IN util_ad9361_adc_fifo/dout_valid_0 1 RX DATA-OUT IP Data 0 OUT util_ad9361_adc_pack/fifo_wr_data_0 16 RX DATA-OUT IP Data 1 OUT util_ad9361_adc_pack/fifo_wr_data_1 16 RX DATA-OUT IP Data 2 OUT util_ad9361_adc_pack/fifo_wr_data_2 16 RX DATA-OUT IP Data 3 OUT util_ad9361_adc_pack/fifo_wr_data_3 16 RX DATA-IN AD9361 ADC Data Q0 util_ad9361_adc_fifo/dout_data_0 16 RX DATA-IN AD9361 ADC Data I0 util_ad9361_adc_fifo/dout_data_1 16 RX DATA-IN AD9361 ADC Data Q1 util_ad9361_adc_fifo/dout_data_2 16 RX DATA-IN AD9361 ADC Data I1 util_ad9361_adc_fifo/dout_data_3 16 RX VALID-IN IP Valid Tx Data IN util_ad9361_dac_upack/fifo_rd_valid 1 TX VALID-OUT IP Load Tx Data OUT axi_ad9361_dac_fifo/din_valid_in_0 1 TX DATA-OUT AD9361 DAC Data Q0 axi_ad9361_dac_fifo/din_data_0 16 TX DATA-OUT AD9361 DAC Data I0 axi_ad9361_dac_fifo/din_data_1 16 TX DATA-OUT AD9361 DAC Data Q1 axi_ad9361_dac_fifo/din_data_2 16 TX DATA-OUT AD9361 DAC Data I1 axi_ad9361_dac_fifo/din_data_3 16 TX DATA-IN IP Data 0 IN util_ad9361_dac_upack/fifo_rd_data_0 16 TX DATA-IN IP Data 1 IN util_ad9361_dac_upack/fifo_rd_data_1 16 TX DATA-IN IP Data 2 IN util_ad9361_dac_upack/fifo_rd_data_2 16 TX DATA-IN IP Data 3 IN util_ad9361_dac_upack/fifo_rd_data_3 16 TX","title":"fmcomms2"},{"location":"hdlrefdesigns/fmcomms2/#fmcomms2-reference-design-integration","text":"This page outlines the HDL reference design integration for the fmcomms2 reference design for the Analog Devices AD9361 component. The IP-Core Generation follow is available on the based on the following base HDL reference design for the following board and design variants: Base reference design documentation Supported FPGA carriers: ZED ZC706 ZC702 Supported design variants: RX TX RX & TX","title":"fmcomms2 Reference Design Integration"},{"location":"hdlrefdesigns/fmcomms2/#reference-design","text":"HDL Reference Design with Custom IP from HDL-Coder. Click on sub-blocks for more documentation. The IP-Core generation flow will integrate IP generated from Simulink subsystem into an ADI authored reference design. Depending on the FPGA carrier and FMC card or SoM, this will support different IP locations based on the diagram above.","title":"Reference Design"},{"location":"hdlrefdesigns/fmcomms2/#hdl-worflow-advisor-port-mappings","text":"When using the HDL Worflow Advisor, the following port mappings are used to connect the reference design to the HDL-Coder generated IP-Core: Type Target Platform Interface (MATLAB) Reference Design Connection (Vivado) Width Reference Design Variant VALID-OUT IP Data Valid OUT util_ad9361_adc_pack/fifo_wr_en 1 RX VALID-IN IP Valid Rx Data IN util_ad9361_adc_fifo/dout_valid_0 1 RX DATA-OUT IP Data 0 OUT util_ad9361_adc_pack/fifo_wr_data_0 16 RX DATA-OUT IP Data 1 OUT util_ad9361_adc_pack/fifo_wr_data_1 16 RX DATA-OUT IP Data 2 OUT util_ad9361_adc_pack/fifo_wr_data_2 16 RX DATA-OUT IP Data 3 OUT util_ad9361_adc_pack/fifo_wr_data_3 16 RX DATA-IN AD9361 ADC Data Q0 util_ad9361_adc_fifo/dout_data_0 16 RX DATA-IN AD9361 ADC Data I0 util_ad9361_adc_fifo/dout_data_1 16 RX DATA-IN AD9361 ADC Data Q1 util_ad9361_adc_fifo/dout_data_2 16 RX DATA-IN AD9361 ADC Data I1 util_ad9361_adc_fifo/dout_data_3 16 RX VALID-IN IP Valid Tx Data IN util_ad9361_dac_upack/fifo_rd_valid 1 TX VALID-OUT IP Load Tx Data OUT axi_ad9361_dac_fifo/din_valid_in_0 1 TX DATA-OUT AD9361 DAC Data Q0 axi_ad9361_dac_fifo/din_data_0 16 TX DATA-OUT AD9361 DAC Data I0 axi_ad9361_dac_fifo/din_data_1 16 TX DATA-OUT AD9361 DAC Data Q1 axi_ad9361_dac_fifo/din_data_2 16 TX DATA-OUT AD9361 DAC Data I1 axi_ad9361_dac_fifo/din_data_3 16 TX DATA-IN IP Data 0 IN util_ad9361_dac_upack/fifo_rd_data_0 16 TX DATA-IN IP Data 1 IN util_ad9361_dac_upack/fifo_rd_data_1 16 TX DATA-IN IP Data 2 IN util_ad9361_dac_upack/fifo_rd_data_2 16 TX DATA-IN IP Data 3 IN util_ad9361_dac_upack/fifo_rd_data_3 16 TX","title":"HDL Worflow Advisor Port Mappings"},{"location":"hdlrefdesigns/pluto/","text":"pluto Reference Design Integration This page outlines the HDL reference design integration for the pluto reference design for the Analog Devices AD9361 component. The IP-Core Generation follow is available on the based on the following base HDL reference design for the following board and design variants: Base reference design documentation Supported FPGA carriers: Supported design variants: RX TX Reference Design HDL Reference Design with Custom IP from HDL-Coder. Click on sub-blocks for more documentation. The IP-Core generation flow will integrate IP generated from Simulink subsystem into an ADI authored reference design. Depending on the FPGA carrier and FMC card or SoM, this will support different IP locations based on the diagram above. HDL Worflow Advisor Port Mappings When using the HDL Worflow Advisor, the following port mappings are used to connect the reference design to the HDL-Coder generated IP-Core: Type Target Platform Interface (MATLAB) Reference Design Connection (Vivado) Width Reference Design Variant VALID-OUT IP Data Valid OUT cpack/fifo_wr_en 1 RX VALID-IN IP Valid Rx Data IN axi_ad9361/adc_valid_i0 1 RX DATA-OUT IP Data 0 OUT cpack/fifo_wr_data_0 16 RX DATA-OUT IP Data 1 OUT cpack/fifo_wr_data_1 16 RX DATA-IN AD9361 ADC Data Q0 axi_ad9361/adc_data_i0 16 RX DATA-IN AD9361 ADC Data Q0 axi_ad9361/adc_data_q0 16 RX VALID-IN IP Valid Tx Data IN tx_upack/fifo_rd_valid 1 TX VALID-OUT IP Load Tx Data OUT logic_or/Op1 1 TX DATA-OUT AD9361 DAC Data Q0 axi_ad9361/dac_data_i0 16 TX DATA-OUT AD9361 DAC Data Q0 axi_ad9361/dac_data_q0 16 TX DATA-IN IP Data 0 IN util_ad9361_dac_upack/fifo_rd_data_0 16 TX DATA-IN IP Data 1 IN util_ad9361_dac_upack/fifo_rd_data_1 16 TX","title":"pluto"},{"location":"hdlrefdesigns/pluto/#pluto-reference-design-integration","text":"This page outlines the HDL reference design integration for the pluto reference design for the Analog Devices AD9361 component. The IP-Core Generation follow is available on the based on the following base HDL reference design for the following board and design variants: Base reference design documentation Supported FPGA carriers: Supported design variants: RX TX","title":"pluto Reference Design Integration"},{"location":"hdlrefdesigns/pluto/#reference-design","text":"HDL Reference Design with Custom IP from HDL-Coder. Click on sub-blocks for more documentation. The IP-Core generation flow will integrate IP generated from Simulink subsystem into an ADI authored reference design. Depending on the FPGA carrier and FMC card or SoM, this will support different IP locations based on the diagram above.","title":"Reference Design"},{"location":"hdlrefdesigns/pluto/#hdl-worflow-advisor-port-mappings","text":"When using the HDL Worflow Advisor, the following port mappings are used to connect the reference design to the HDL-Coder generated IP-Core: Type Target Platform Interface (MATLAB) Reference Design Connection (Vivado) Width Reference Design Variant VALID-OUT IP Data Valid OUT cpack/fifo_wr_en 1 RX VALID-IN IP Valid Rx Data IN axi_ad9361/adc_valid_i0 1 RX DATA-OUT IP Data 0 OUT cpack/fifo_wr_data_0 16 RX DATA-OUT IP Data 1 OUT cpack/fifo_wr_data_1 16 RX DATA-IN AD9361 ADC Data Q0 axi_ad9361/adc_data_i0 16 RX DATA-IN AD9361 ADC Data Q0 axi_ad9361/adc_data_q0 16 RX VALID-IN IP Valid Tx Data IN tx_upack/fifo_rd_valid 1 TX VALID-OUT IP Load Tx Data OUT logic_or/Op1 1 TX DATA-OUT AD9361 DAC Data Q0 axi_ad9361/dac_data_i0 16 TX DATA-OUT AD9361 DAC Data Q0 axi_ad9361/dac_data_q0 16 TX DATA-IN IP Data 0 IN util_ad9361_dac_upack/fifo_rd_data_0 16 TX DATA-IN IP Data 1 IN util_ad9361_dac_upack/fifo_rd_data_1 16 TX","title":"HDL Worflow Advisor Port Mappings"},{"location":"sysobjects/adi.AD9361.Rx/","text":"The adi.AD9361.Rx System object is a signal source that can receive complex data from the AD9361. rx = adi.AD9361.Rx; rx = adi.AD9361.Rx('uri','ip:192.168.2.1'); AD9361 Datasheet Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . AD9361 . Rx dev = adi . AD9361 . Rx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. CenterFrequency + RF center frequency, specified in Hz as a scalar. The default is 2.4e9. This property is tunable. SamplingRate + Baseband sampling rate in Hz, specified as a scalar from 65105 to 61.44e6 samples per second. RFBandwidth + RF Bandwidth of front-end analog filter in Hz, specified as a scalar from 200 kHz to 56 MHz. GainControlModeChannel0 + specified as one of the following: 'slow_attack' \u2014 For signals with slowly changing power levels 'fast_attack' \u2014 For signals with rapidly changing power levels 'manual' \u2014 For setting the gain manually with the Gain property 'hybrid' \u2014 For configuring hybrid AGC mode GainChannel0 + Channel 0 gain, specified as a scalar from -3 dB to 71 dB. The acceptable minimum and maximum gain setting depends on the center frequency. GainControlModeChannel1 + specified as one of the following: 'slow_attack' \u2014 For signals with slowly changing power levels 'fast_attack' \u2014 For signals with rapidly changing power levels 'manual' \u2014 For setting the gain manually with the Gain property 'hybrid' \u2014 For configuring hybrid AGC mode GainChannel1 + Channel 1 gain, specified as a scalar from -3 dB to 71 dB. The acceptable minimum and maximum gain setting depends on the center frequency. LoopbackMode + Option to set digital loopback mode, specified as 0, 1 or 2. Allows either to digitally loopback TX data into the RX path or vice versa. Value | Mode --------------------------- 0 | Disable 1 | Digital TX -> Digital RX 2 | RF RX -> RF TX EnableQuadratureTracking + Option to enable quadrature tracking, specified as true or false. When this property is true, IQ imbalance compensation is applied to the input signal. EnableRFDCTracking + Option to enable RF DC tracking, specified as true or false. When this property is true, an RF DC blocking filter is applied to the input signal. EnableBasebandDCTracking + Option to enable baseband DC tracking, specified as true or false. When this property is true, a baseband DC blocking filter is applied to the input signal. RFPortSelect + 'A_BALANCED' 'B_BALANCED' 'C_BALANCED' 'A_N' 'A_P' 'B_N' 'B_P' 'C_N' 'C_P' 'TX_MONITOR1' 'TX_MONITOR2' 'TX_MONITOR1_2' SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance. EnableCustomFilter + Enable use of custom filter file to set SamplingRate, RFBandwidth, and FIR in datapaths CustomFilterFileName + Path to custom filter file created from filter wizard EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.AD9361.Rx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE enIO + If true, connects to libIIO device during simulationHelp for adi.AD9361.Rx/enIO is inherited from superclass MATLABSHARED.LIBIIO.BASE Example Usage %% Rx set up rx = adi.adi.AD9361.Rx.Rx('uri','ip:analog.local'); rx.CenterFrequency = 1e9; rx.EnabledChannels = 1; %% Run for k=1:10 valid = false; while ~valid [out, valid] = rx(); end end","title":"adi.AD9361.Rx"},{"location":"sysobjects/adi.AD9361.Tx/","text":"The adi.AD9361.Tx System object is a signal sink that can tranmsit complex data from the AD9361. tx = adi.AD9361.Tx; tx = adi.AD9361.Tx('uri','ip:192.168.2.1'); AD9361 Datasheet Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . AD9361 . Tx dev = adi . AD9361 . Tx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. CenterFrequency + RF center frequency, specified in Hz as a scalar. The default is 2.4e9. This property is tunable. SamplingRate + Baseband sampling rate in Hz, specified as a scalar from 65105 to 61.44e6 samples per second. RFBandwidth + RF Bandwidth of front-end analog filter in Hz, specified as a scalar from 200 kHz to 56 MHz. AttenuationChannel0 + Attentuation specified as a scalar from -89.75 to 0 dB with a resolution of 0.25 dB. AttenuationChannel1 + Attentuation specified as a scalar from -89.75 to 0 dB with a resolution of 0.25 dB. RFPortSelect + 'A' 'B' SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance. EnableCustomFilter + Enable use of custom filter file to set SamplingRate, RFBandwidth, and FIR in datapaths CustomFilterFileName + Path to custom filter file created from filter wizard EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.AD9361.Tx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE enIO + If true, connects to libIIO device during simulationHelp for adi.AD9361.Tx/enIO is inherited from superclass MATLABSHARED.LIBIIO.BASE DataSource + Data source, specified as one of the following: 'DMA' \u2014 Specify the host as the source of the data. 'DDS' \u2014 Specify the DDS on the radio hardware as the source of the data. In this case, each channel has two additive tones.Help for adi.AD9361.Tx/DataSource is inherited from superclass ADI.COMMON.DDS DDSFrequencies + Frequencies values in Hz of the DDS tone generators. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.AD9361.Tx/DDSFrequencies is inherited from superclass ADI.COMMON.DDS DDSScales + Scale of DDS tones in range [0,1]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.AD9361.Tx/DDSScales is inherited from superclass ADI.COMMON.DDS DDSPhases + Phases of DDS tones in range [0,360000]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.AD9361.Tx/DDSPhases is inherited from superclass ADI.COMMON.DDS EnableCyclicBuffers + Enable Cyclic Buffers, configures transmit buffers to be cyclic, which makes them continuously repeatHelp for adi.AD9361.Tx/EnableCyclicBuffers is inherited from superclass ADI.COMMON.DDS Example Usage %% Configure device tx = adi.adi.AD9361.Tx; tx.uri = \"ip:analog.local\"; tx.CenterFrequency = 1e9; tx.DataSource = 'DMA'; tx.EnableCyclicBuffers = true; tx.EnabledChannels = 1; %% Generate tone amplitude = 2^15; frequency = 0.12e6; swv1 = dsp.SineWave(amplitude, frequency); swv1.ComplexOutput = true; swv1.SamplesPerFrame = 2^14; swv1.SampleRate = tx.SamplingRate; y = swv1(); % Send tx(y);","title":"adi.AD9361.Tx"},{"location":"sysobjects/adi.AD9363.Rx/","text":"The adi.AD9363.Rx System object is a signal source that can receive complex data from the AD9364. rx = adi.AD9363.Rx; rx = adi.AD9363.Rx('uri','ip:192.168.2.1'); AD9363 Datasheet Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . AD9363 . Rx dev = adi . AD9363 . Rx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. CenterFrequency + RF center frequency, specified in Hz as a scalar. The default is 2.4e9. This property is tunable.Help for adi.AD9363.Rx/CenterFrequency is inherited from superclass ADI.AD9361.RX SamplingRate + Baseband sampling rate in Hz, specified as a scalar from 65105 to 61.44e6 samples per second.Help for adi.AD9363.Rx/SamplingRate is inherited from superclass ADI.AD9361.RX RFBandwidth + RF Bandwidth of front-end analog filter in Hz, specified as a scalar from 200 kHz to 56 MHz.Help for adi.AD9363.Rx/RFBandwidth is inherited from superclass ADI.AD9361.RX GainControlModeChannel0 + specified as one of the following: 'slow_attack' \u2014 For signals with slowly changing power levels 'fast_attack' \u2014 For signals with rapidly changing power levels 'manual' \u2014 For setting the gain manually with the Gain property 'hybrid' \u2014 For configuring hybrid AGC modeHelp for adi.AD9363.Rx/GainControlModeChannel0 is inherited from superclass ADI.AD9361.RX GainChannel0 + Channel 0 gain, specified as a scalar from -3 dB to 71 dB. The acceptable minimum and maximum gain setting depends on the center frequency.Help for adi.AD9363.Rx/GainChannel0 is inherited from superclass ADI.AD9361.RX GainControlModeChannel1 + specified as one of the following: 'slow_attack' \u2014 For signals with slowly changing power levels 'fast_attack' \u2014 For signals with rapidly changing power levels 'manual' \u2014 For setting the gain manually with the Gain property 'hybrid' \u2014 For configuring hybrid AGC modeHelp for adi.AD9363.Rx/GainControlModeChannel1 is inherited from superclass ADI.AD9361.RX GainChannel1 + Channel 1 gain, specified as a scalar from -3 dB to 71 dB. The acceptable minimum and maximum gain setting depends on the center frequency.Help for adi.AD9363.Rx/GainChannel1 is inherited from superclass ADI.AD9361.RX LoopbackMode + Option to set digital loopback mode, specified as 0, 1 or 2. Allows either to digitally loopback TX data into the RX path or vice versa. Value | Mode --------------------------- 0 | Disable 1 | Digital TX -> Digital RX 2 | RF RX -> RF TX Help for adi.AD9363.Rx/LoopbackMode is inherited from superclass ADI.AD9361.RX EnableQuadratureTracking + Option to enable quadrature tracking, specified as true or false. When this property is true, IQ imbalance compensation is applied to the input signal.Help for adi.AD9363.Rx/EnableQuadratureTracking is inherited from superclass ADI.AD9361.RX EnableRFDCTracking + Option to enable RF DC tracking, specified as true or false. When this property is true, an RF DC blocking filter is applied to the input signal.Help for adi.AD9363.Rx/EnableRFDCTracking is inherited from superclass ADI.AD9361.RX EnableBasebandDCTracking + Option to enable baseband DC tracking, specified as true or false. When this property is true, a baseband DC blocking filter is applied to the input signal.Help for adi.AD9363.Rx/EnableBasebandDCTracking is inherited from superclass ADI.AD9361.RX RFPortSelect + 'A_BALANCED' 'B_BALANCED' 'C_BALANCED' 'A_N' 'A_P' 'B_N' 'B_P' 'C_N' 'C_P' 'TX_MONITOR1' 'TX_MONITOR2' 'TX_MONITOR1_2'Help for adi.AD9363.Rx/RFPortSelect is inherited from superclass ADI.AD9361.RX SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance. EnableCustomFilter + Enable use of custom filter file to set SamplingRate, RFBandwidth, and FIR in datapaths CustomFilterFileName + Path to custom filter file created from filter wizard EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.AD9363.Rx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE enIO + If true, connects to libIIO device during simulationHelp for adi.AD9363.Rx/enIO is inherited from superclass MATLABSHARED.LIBIIO.BASE Example Usage %% Rx set up rx = adi.adi.AD9363.Rx.Rx('uri','ip:analog.local'); rx.CenterFrequency = 1e9; rx.EnabledChannels = 1; %% Run for k=1:10 valid = false; while ~valid [out, valid] = rx(); end end","title":"adi.AD9363.Rx"},{"location":"sysobjects/adi.AD9363.Tx/","text":"The adi.AD9363.Tx System object is a signal sink that can transmit complex data from the AD9364. tx = adi.AD9363.Tx; tx = adi.AD9363.Tx('uri','ip:192.168.2.1'); AD9363 Datasheet Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . AD9363 . Tx dev = adi . AD9363 . Tx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. CenterFrequency + RF center frequency, specified in Hz as a scalar. The default is 2.4e9. This property is tunable.Help for adi.AD9363.Tx/CenterFrequency is inherited from superclass ADI.AD9361.TX SamplingRate + Baseband sampling rate in Hz, specified as a scalar from 65105 to 61.44e6 samples per second.Help for adi.AD9363.Tx/SamplingRate is inherited from superclass ADI.AD9361.TX RFBandwidth + RF Bandwidth of front-end analog filter in Hz, specified as a scalar from 200 kHz to 56 MHz.Help for adi.AD9363.Tx/RFBandwidth is inherited from superclass ADI.AD9361.TX AttenuationChannel0 + Attentuation specified as a scalar from -89.75 to 0 dB with a resolution of 0.25 dB.Help for adi.AD9363.Tx/AttenuationChannel0 is inherited from superclass ADI.AD9361.TX AttenuationChannel1 + Attentuation specified as a scalar from -89.75 to 0 dB with a resolution of 0.25 dB.Help for adi.AD9363.Tx/AttenuationChannel1 is inherited from superclass ADI.AD9361.TX RFPortSelect + 'A' 'B'Help for adi.AD9363.Tx/RFPortSelect is inherited from superclass ADI.AD9361.TX SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance. EnableCustomFilter + Enable use of custom filter file to set SamplingRate, RFBandwidth, and FIR in datapaths CustomFilterFileName + Path to custom filter file created from filter wizard EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.AD9363.Tx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE enIO + If true, connects to libIIO device during simulationHelp for adi.AD9363.Tx/enIO is inherited from superclass MATLABSHARED.LIBIIO.BASE DataSource + Data source, specified as one of the following: 'DMA' \u2014 Specify the host as the source of the data. 'DDS' \u2014 Specify the DDS on the radio hardware as the source of the data. In this case, each channel has two additive tones.Help for adi.AD9363.Tx/DataSource is inherited from superclass ADI.COMMON.DDS DDSFrequencies + Frequencies values in Hz of the DDS tone generators. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.AD9363.Tx/DDSFrequencies is inherited from superclass ADI.COMMON.DDS DDSScales + Scale of DDS tones in range [0,1]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.AD9363.Tx/DDSScales is inherited from superclass ADI.COMMON.DDS DDSPhases + Phases of DDS tones in range [0,360000]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.AD9363.Tx/DDSPhases is inherited from superclass ADI.COMMON.DDS EnableCyclicBuffers + Enable Cyclic Buffers, configures transmit buffers to be cyclic, which makes them continuously repeatHelp for adi.AD9363.Tx/EnableCyclicBuffers is inherited from superclass ADI.COMMON.DDS Example Usage %% Configure device tx = adi.adi.AD9363.Tx; tx.uri = \"ip:analog.local\"; tx.CenterFrequency = 1e9; tx.DataSource = 'DMA'; tx.EnableCyclicBuffers = true; tx.EnabledChannels = 1; %% Generate tone amplitude = 2^15; frequency = 0.12e6; swv1 = dsp.SineWave(amplitude, frequency); swv1.ComplexOutput = true; swv1.SamplesPerFrame = 2^14; swv1.SampleRate = tx.SamplingRate; y = swv1(); % Send tx(y);","title":"adi.AD9363.Tx"},{"location":"sysobjects/adi.AD9364.Rx/","text":"The adi.AD9361.Rx System object is a signal source that can receive complex data from the AD9364. rx = adi.AD9364.Rx; rx = adi.AD9364.Rx('uri','ip:192.168.2.1'); AD9364 Datasheet Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . AD9364 . Rx dev = adi . AD9364 . Rx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. CenterFrequency + RF center frequency, specified in Hz as a scalar. The default is 2.4e9. This property is tunable.Help for adi.AD9364.Rx/CenterFrequency is inherited from superclass ADI.AD9361.RX SamplingRate + Baseband sampling rate in Hz, specified as a scalar from 65105 to 61.44e6 samples per second.Help for adi.AD9364.Rx/SamplingRate is inherited from superclass ADI.AD9361.RX RFBandwidth + RF Bandwidth of front-end analog filter in Hz, specified as a scalar from 200 kHz to 56 MHz.Help for adi.AD9364.Rx/RFBandwidth is inherited from superclass ADI.AD9361.RX GainControlModeChannel0 + specified as one of the following: 'slow_attack' \u2014 For signals with slowly changing power levels 'fast_attack' \u2014 For signals with rapidly changing power levels 'manual' \u2014 For setting the gain manually with the Gain property 'hybrid' \u2014 For configuring hybrid AGC modeHelp for adi.AD9364.Rx/GainControlModeChannel0 is inherited from superclass ADI.AD9361.RX GainChannel0 + Channel 0 gain, specified as a scalar from -3 dB to 71 dB. The acceptable minimum and maximum gain setting depends on the center frequency.Help for adi.AD9364.Rx/GainChannel0 is inherited from superclass ADI.AD9361.RX GainControlModeChannel1 + specified as one of the following: 'slow_attack' \u2014 For signals with slowly changing power levels 'fast_attack' \u2014 For signals with rapidly changing power levels 'manual' \u2014 For setting the gain manually with the Gain property 'hybrid' \u2014 For configuring hybrid AGC modeHelp for adi.AD9364.Rx/GainControlModeChannel1 is inherited from superclass ADI.AD9361.RX GainChannel1 + Channel 1 gain, specified as a scalar from -3 dB to 71 dB. The acceptable minimum and maximum gain setting depends on the center frequency.Help for adi.AD9364.Rx/GainChannel1 is inherited from superclass ADI.AD9361.RX LoopbackMode + Option to set digital loopback mode, specified as 0, 1 or 2. Allows either to digitally loopback TX data into the RX path or vice versa. Value | Mode --------------------------- 0 | Disable 1 | Digital TX -> Digital RX 2 | RF RX -> RF TX Help for adi.AD9364.Rx/LoopbackMode is inherited from superclass ADI.AD9361.RX EnableQuadratureTracking + Option to enable quadrature tracking, specified as true or false. When this property is true, IQ imbalance compensation is applied to the input signal.Help for adi.AD9364.Rx/EnableQuadratureTracking is inherited from superclass ADI.AD9361.RX EnableRFDCTracking + Option to enable RF DC tracking, specified as true or false. When this property is true, an RF DC blocking filter is applied to the input signal.Help for adi.AD9364.Rx/EnableRFDCTracking is inherited from superclass ADI.AD9361.RX EnableBasebandDCTracking + Option to enable baseband DC tracking, specified as true or false. When this property is true, a baseband DC blocking filter is applied to the input signal.Help for adi.AD9364.Rx/EnableBasebandDCTracking is inherited from superclass ADI.AD9361.RX RFPortSelect + 'A_BALANCED' 'B_BALANCED' 'C_BALANCED' 'A_N' 'A_P' 'B_N' 'B_P' 'C_N' 'C_P' 'TX_MONITOR1' 'TX_MONITOR2' 'TX_MONITOR1_2'Help for adi.AD9364.Rx/RFPortSelect is inherited from superclass ADI.AD9361.RX SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance. EnableCustomFilter + Enable use of custom filter file to set SamplingRate, RFBandwidth, and FIR in datapaths CustomFilterFileName + Path to custom filter file created from filter wizard EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.AD9364.Rx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE enIO + If true, connects to libIIO device during simulationHelp for adi.AD9364.Rx/enIO is inherited from superclass MATLABSHARED.LIBIIO.BASE Example Usage %% Rx set up rx = adi.adi.AD9364.Rx.Rx('uri','ip:analog.local'); rx.CenterFrequency = 1e9; rx.EnabledChannels = 1; %% Run for k=1:10 valid = false; while ~valid [out, valid] = rx(); end end","title":"adi.AD9364.Rx"},{"location":"sysobjects/adi.AD9364.Tx/","text":"The adi.AD9361.Rx System object is a signal sink that can transmit complex data from the AD9364. tx = adi.AD9364.Tx; tx = adi.AD9364.Tx('uri','ip:192.168.2.1'); AD9364 Datasheet Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . AD9364 . Tx dev = adi . AD9364 . Tx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. CenterFrequency + RF center frequency, specified in Hz as a scalar. The default is 2.4e9. This property is tunable.Help for adi.AD9364.Tx/CenterFrequency is inherited from superclass ADI.AD9361.TX SamplingRate + Baseband sampling rate in Hz, specified as a scalar from 65105 to 61.44e6 samples per second.Help for adi.AD9364.Tx/SamplingRate is inherited from superclass ADI.AD9361.TX RFBandwidth + RF Bandwidth of front-end analog filter in Hz, specified as a scalar from 200 kHz to 56 MHz.Help for adi.AD9364.Tx/RFBandwidth is inherited from superclass ADI.AD9361.TX AttenuationChannel0 + Attentuation specified as a scalar from -89.75 to 0 dB with a resolution of 0.25 dB.Help for adi.AD9364.Tx/AttenuationChannel0 is inherited from superclass ADI.AD9361.TX AttenuationChannel1 + Attentuation specified as a scalar from -89.75 to 0 dB with a resolution of 0.25 dB.Help for adi.AD9364.Tx/AttenuationChannel1 is inherited from superclass ADI.AD9361.TX RFPortSelect + 'A' 'B'Help for adi.AD9364.Tx/RFPortSelect is inherited from superclass ADI.AD9361.TX SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance. EnableCustomFilter + Enable use of custom filter file to set SamplingRate, RFBandwidth, and FIR in datapaths CustomFilterFileName + Path to custom filter file created from filter wizard EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.AD9364.Tx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE enIO + If true, connects to libIIO device during simulationHelp for adi.AD9364.Tx/enIO is inherited from superclass MATLABSHARED.LIBIIO.BASE DataSource + Data source, specified as one of the following: 'DMA' \u2014 Specify the host as the source of the data. 'DDS' \u2014 Specify the DDS on the radio hardware as the source of the data. In this case, each channel has two additive tones.Help for adi.AD9364.Tx/DataSource is inherited from superclass ADI.COMMON.DDS DDSFrequencies + Frequencies values in Hz of the DDS tone generators. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.AD9364.Tx/DDSFrequencies is inherited from superclass ADI.COMMON.DDS DDSScales + Scale of DDS tones in range [0,1]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.AD9364.Tx/DDSScales is inherited from superclass ADI.COMMON.DDS DDSPhases + Phases of DDS tones in range [0,360000]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.AD9364.Tx/DDSPhases is inherited from superclass ADI.COMMON.DDS EnableCyclicBuffers + Enable Cyclic Buffers, configures transmit buffers to be cyclic, which makes them continuously repeatHelp for adi.AD9364.Tx/EnableCyclicBuffers is inherited from superclass ADI.COMMON.DDS Example Usage %% Configure device tx = adi.adi.AD9364.Tx; tx.uri = \"ip:analog.local\"; tx.CenterFrequency = 1e9; tx.DataSource = 'DMA'; tx.EnableCyclicBuffers = true; tx.EnabledChannels = 1; %% Generate tone amplitude = 2^15; frequency = 0.12e6; swv1 = dsp.SineWave(amplitude, frequency); swv1.ComplexOutput = true; swv1.SamplesPerFrame = 2^14; swv1.SampleRate = tx.SamplingRate; y = swv1(); % Send tx(y);","title":"adi.AD9364.Tx"},{"location":"sysobjects/adi.AD9371.Rx/","text":"The adi.AD9371.Rx System object is a signal source that can receive complex data from the AD9371. rx = adi.AD9371.Rx; rx = adi.AD9371.Rx('uri','ip:192.168.2.1'); AD9371 Datasheet Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . AD9371 . Rx dev = adi . AD9371 . Rx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. GainControlMode + specified as one of the following: 'slow_attack' \u2014 For signals with slowly changing power levels 'fast_attack' \u2014 For signals with rapidly changing power levels 'manual' \u2014 For setting the gain manually with the Gain property 'hybrid' \u2014 For configuring hybrid AGC mode GainChannel0 + Channel 0 gain, specified as a scalar from -4 dB to 71 dB. The acceptable minimum and maximum gain setting depends on the center frequency. GainChannel1 + Channel 1 gain, specified as a scalar from -4 dB to 71 dB. The acceptable minimum and maximum gain setting depends on the center frequency. LoopbackMode + Option to set digital loopback mode, specified as 0 or 1. Allows digital loopback of TX data into the RX path. Value | Mode --------------------------- 0 | Disable 1 | Enable EnableQuadratureTrackingChannel0 + Option to enable quadrature tracking, specified as true or false. When this property is true, IQ imbalance compensation is applied to the input signal. EnableQuadratureTrackingChannel1 + Option to enable quadrature tracking, specified as true or false. When this property is true, IQ imbalance compensation is applied to the input signal. SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance. EnableCustomProfile + Enable use of custom Profile file to set SamplingRate, RFBandwidth, and FIR in datapaths CustomProfileFileName + Path to custom Profile file created from profile wizard CenterFrequency + RF center frequency, specified in Hz as a scalar. The default is 2.4e9. This property is tunable. EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.AD9371.Rx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE enIO + If true, connects to libIIO device during simulationHelp for adi.AD9371.Rx/enIO is inherited from superclass MATLABSHARED.LIBIIO.BASE Example Usage %% Rx set up rx = adi.adi.AD9371.Rx.Rx('uri','ip:analog.local'); rx.CenterFrequency = 1e9; rx.EnabledChannels = 1; %% Run for k=1:10 valid = false; while ~valid [out, valid] = rx(); end end","title":"adi.AD9371.Rx"},{"location":"sysobjects/adi.AD9371.Tx/","text":"The adi.AD9371.Tx System object is a signal sink that can tranmsit complex data from the AD9371. tx = adi.AD9371.Tx; tx = adi.AD9371.Tx('uri','ip:192.168.2.1'); AD9371 Datasheet Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . AD9371 . Tx dev = adi . AD9371 . Tx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. AttenuationChannel0 + Attentuation specified as a scalar from -89.75 to 0 dB with a resolution of 0.25 dB. AttenuationChannel1 + Attentuation specified as a scalar from -89.75 to 0 dB with a resolution of 0.25 dB. SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance. EnableCustomProfile + Enable use of custom Profile file to set SamplingRate, RFBandwidth, and FIR in datapaths CustomProfileFileName + Path to custom Profile file created from profile wizard CenterFrequency + RF center frequency, specified in Hz as a scalar. The default is 2.4e9. This property is tunable. EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.AD9371.Tx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE enIO + If true, connects to libIIO device during simulationHelp for adi.AD9371.Tx/enIO is inherited from superclass MATLABSHARED.LIBIIO.BASE DataSource + Data source, specified as one of the following: 'DMA' \u2014 Specify the host as the source of the data. 'DDS' \u2014 Specify the DDS on the radio hardware as the source of the data. In this case, each channel has two additive tones.Help for adi.AD9371.Tx/DataSource is inherited from superclass ADI.COMMON.DDS DDSFrequencies + Frequencies values in Hz of the DDS tone generators. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.AD9371.Tx/DDSFrequencies is inherited from superclass ADI.COMMON.DDS DDSScales + Scale of DDS tones in range [0,1]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.AD9371.Tx/DDSScales is inherited from superclass ADI.COMMON.DDS DDSPhases + Phases of DDS tones in range [0,360000]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.AD9371.Tx/DDSPhases is inherited from superclass ADI.COMMON.DDS EnableCyclicBuffers + Enable Cyclic Buffers, configures transmit buffers to be cyclic, which makes them continuously repeatHelp for adi.AD9371.Tx/EnableCyclicBuffers is inherited from superclass ADI.COMMON.DDS Example Usage %% Configure device tx = adi.adi.AD9371.Tx; tx.uri = \"ip:analog.local\"; tx.CenterFrequency = 1e9; tx.DataSource = 'DMA'; tx.EnableCyclicBuffers = true; tx.EnabledChannels = 1; %% Generate tone amplitude = 2^15; frequency = 0.12e6; swv1 = dsp.SineWave(amplitude, frequency); swv1.ComplexOutput = true; swv1.SamplesPerFrame = 2^14; swv1.SampleRate = tx.SamplingRate; y = swv1(); % Send tx(y);","title":"adi.AD9371.Tx"},{"location":"sysobjects/adi.ADRV9002.Rx/","text":"The adi.ADRV9002.Rx System object is a signal source that can receive complex data from the ADRV9002. rx = adi.ADRV9002.Rx; rx = adi.ADRV9002.Rx('uri','ip:192.168.2.1'); ADRV9002 Datasheet Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . ADRV9002 . Rx dev = adi . ADRV9002 . Rx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. ENSMModeChannel0 + specified as one of the following: 'calibrated' 'primed' 'rf_enabled' ENSMModeChannel1 + specified as one of the following: 'calibrated' 'primed' 'rf_enabled' InterfaceGainChannel0 + This is the final gain in the digital path with possible values: -36:6:18 This gain should be selected based on primary signal bandwidth. For narrowband applications higher levels of interface gain should be used (0:18) to allow signal level and analog noise to dominate. For wideband applications this gain should be reduced or disabled since quantization noise is minimal. InterfaceGainChannel1 + This is the final gain in the digital path with possible values: -36:6:18 This gain should be selected based on primary signal bandwidth. For narrowband applications higher levels of interface gain should be used (0:18) to allow signal level and analog noise to dominate. For wideband applications this gain should be reduced or disabled since quantization noise is minimal. DigitalGainControlModeChannel0 + The digital gain control has two major purposes, one for gain correction which is to correct the small step size inaccuracy in analog front-end attenuation and the other for gain compensation which is to compensate for the entire analog front-end attenuation. The digital gain block is controlled by the Rx gain table. Different digital gain will be applied when configured in gain correction or gain compensation mode. The Rx gain table has a unique front-end attenuator setting, with a corresponding amount of digital gain, programmed at each index of the table. In the end of the Rx data path, the interface gain could be further applied by using a \u201cSlicer\u201d block for 2 major purposes. One is to avoid digital saturation in gain compensation mode. The other one is to ensure the overall SNR is limited only by analog noise and unaffected by quantization noise. Gain correction should be used when external components (LNA or DSA) does not need to be controlled. Compensation should be used for external LNA or DSA control. Gain control is specified as one of the following: 'AutomaticGainCorrection' - Automatically adjust interface gain 'ManualGainCorrection' - Manually adjust interface gain 'AutomaticGainCompensation' - Automatically adjust interface gain and external gain element 'ManualGainCompensation' - Manually adjust interface gain and external gain element DigitalGainControlModeChannel1 + The digital gain control has two major purposes, one for gain correction which is to correct the small step size inaccuracy in analog front-end attenuation and the other for gain compensation which is to compensate for the entire analog front-end attenuation. The digital gain block is controlled by the Rx gain table. Different digital gain will be applied when configured in gain correction or gain compensation mode. The Rx gain table has a unique front-end attenuator setting, with a corresponding amount of digital gain, programmed at each index of the table. In the end of the Rx data path, the interface gain could be further applied by using a \u201cSlicer\u201d block for 2 major purposes. One is to avoid digital saturation in gain compensation mode. The other one is to ensure the overall SNR is limited only by analog noise and unaffected by quantization noise. Gain correction should be used when external components (LNA or DSA) does not need to be controlled. Compensation should be used for external LNA or DSA control. Gain control is specified as one of the following: 'AutomaticGainCorrection' - Automatically adjust interface gain 'ManualGainCorrection' - Manually adjust interface gain 'AutomaticGainCompensation' - Automatically adjust interface gain and external gain element 'ManualGainCompensation' - Manually adjust interface gain and external gain element AttenuationChannel0 + Must be greater than 0 AttenuationChannel1 + Must be greater than 0 ENSMPortModeChannel0 + specified as one of the following: 'spi' 'pin' ENSMPortModeChannel1 + specified as one of the following: 'spi' 'pin' GainControllerSourceChannel0 + specified as one of the following: 'spi' 'pin' 'automatic' GainControllerSourceChannel1 + specified as one of the following: 'spi' 'pin' 'automatic' PowerdownChannel0 + PowerdownChannel1 + AGCTrackingChannel0 + AGC on the fly tracking calibration for Channel 0 AGCTrackingChannel1 + AGC on the fly tracking calibration for Channel 1 BBDCRejectionTrackingChannel0 + Baseband DC rejection on the fly tracking calibration for Channel 0 BBDCRejectionTrackingChannel1 + Baseband DC rejection on the fly tracking calibration for Channel 1 HDTrackingChannel0 + Harmonic Distortion on the fly tracking calibration for Channel 0 HDTrackingChannel1 + Harmonic Distortion on the fly tracking calibration for Channel 1 QuadratureFICTrackingChannel0 + Quadrature Error Correction Narrowband FIC on the fly tracking calibration for channel 0 QuadratureFICTrackingChannel1 + Quadrature Error Correction Narrowband FIC on the fly tracking calibration for channel 1 QuadratureWidebandPolyTrackingChannel0 + Quadrature Error Correction Wideband Poly on the fly tracking calibration for channel 0 QuadratureWidebandPolyTrackingChannel1 + Quadrature Error Correction Wideband Poly on the fly tracking calibration for channel 1 RFDCTrackingChannel0 + RF DC on the fly tracking calibration for channel 0 RFDCTrackingChannel1 + RF DC on the fly tracking calibration for channel 1 RSSITrackingChannel0 + RSSI on the fly tracking calibration for channel 0 RSSITrackingChannel1 + RSSI on the fly tracking calibration for channel 1 RSSIChannel0 + Received signal strength indicator. This valid is only valid once the object has been stepped and MATLAB connects to hardware RSSIChannel1 + Received signal strength indicator. This valid is only valid once the object has been stepped and MATLAB connects to hardware SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance. EnableCustomProfile + Enable use of custom Profile file to set SamplingRate, RFBandwidth, and other features of transceiver CustomProfileFileName + Path to custom Profile file created from profile wizard CustomStreamFileName + Path to custom stream file created from profile wizard SamplingRate + Baseband sampling rate in Hz, specified as a scalar in samples per second. This is a read-only property CenterFrequencyChannel0 + RF center frequency, specified in Hz as a scalar. The default is 2.4e9. This property is tunable. CenterFrequencyChannel1 + RF center frequency, specified in Hz as a scalar. The default is 2.4e9. This property is tunable. NCOCorrectionFrequencyChannel0 + NCO correction frequency, specified in Hz as a scalar. The default is 0. This property is tunable. NCOCorrectionFrequencyChannel1 + NCO correction frequency, specified in Hz as a scalar. The default is 0. This property is tunable. EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.ADRV9002.Rx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE enIO + If true, connects to libIIO device during simulationHelp for adi.ADRV9002.Rx/enIO is inherited from superclass MATLABSHARED.LIBIIO.BASE Example Usage %% Rx set up rx = adi.adi.ADRV9002.Rx.Rx('uri','ip:analog.local'); rx.CenterFrequency = 1e9; rx.EnabledChannels = 1; %% Run for k=1:10 valid = false; while ~valid [out, valid] = rx(); end end","title":"adi.ADRV9002.Rx"},{"location":"sysobjects/adi.ADRV9002.Tx/","text":"The adi.ADRV9002.Tx System object is a signal sink that can tranmsit complex data from the ADRV9002. tx = adi.ADRV9002.Tx; tx = adi.ADRV9002.Tx('uri','ip:192.168.2.1'); ADRV9002 Datasheet Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . ADRV9002 . Tx dev = adi . ADRV9002 . Tx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. ENSMModeChannel0 + specified as one of the following: 'calibrated' 'primed' 'rf_enabled' ENSMModeChannel1 + specified as one of the following: 'calibrated' 'primed' 'rf_enabled' AttenuationChannel0 + Attentuation specified as a scalar from -89.75 to 0 dB with a resolution of 0.25 dB. AttenuationChannel1 + Attentuation specified as a scalar from -89.75 to 0 dB with a resolution of 0.25 dB. AttenuationControlModeChannel0 + Control attenuation through: - bypass - spi - pin AttenuationControlModeChannel1 + Control attenuation through: - bypass - spi - pin PortEnableControlChannel0 + specified as one of the following: 'spi' 'pin' PortEnableControlChannel1 + specified as one of the following: 'spi' 'pin' ClosedLoopTrackingChannel0 + ClosedLoopTrackingChannel1 + LOLeakageTrackingChannel0 + LOLeakageTrackingChannel1 + LoopbackDelayTrackingChannel0 + LoopbackDelayTrackingChannel1 + PACorrectionTrackingChannel0 + PACorrectionTrackingChannel1 + QuadratureTrackingChannel0 + Quadrature Error Correction on the fly tracking calibration for channel 0 QuadratureTrackingChannel1 + Quadrature Error Correction on the fly tracking calibration for channel 1 SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance. EnableCustomProfile + Enable use of custom Profile file to set SamplingRate, RFBandwidth, and other features of transceiver CustomProfileFileName + Path to custom Profile file created from profile wizard CustomStreamFileName + Path to custom stream file created from profile wizard SamplingRate + Baseband sampling rate in Hz, specified as a scalar in samples per second. This is a read-only property CenterFrequencyChannel0 + RF center frequency, specified in Hz as a scalar. The default is 2.4e9. This property is tunable. CenterFrequencyChannel1 + RF center frequency, specified in Hz as a scalar. The default is 2.4e9. This property is tunable. NCOCorrectionFrequencyChannel0 + NCO correction frequency, specified in Hz as a scalar. The default is 0. This property is tunable. NCOCorrectionFrequencyChannel1 + NCO correction frequency, specified in Hz as a scalar. The default is 0. This property is tunable. EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.ADRV9002.Tx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE enIO + If true, connects to libIIO device during simulationHelp for adi.ADRV9002.Tx/enIO is inherited from superclass MATLABSHARED.LIBIIO.BASE DataSource + Data source, specified as one of the following: 'DMA' \u2014 Specify the host as the source of the data. 'DDS' \u2014 Specify the DDS on the radio hardware as the source of the data. In this case, each channel has two additive tones.Help for adi.ADRV9002.Tx/DataSource is inherited from superclass ADI.COMMON.DDS DDSFrequencies + Frequencies values in Hz of the DDS tone generators. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.ADRV9002.Tx/DDSFrequencies is inherited from superclass ADI.COMMON.DDS DDSScales + Scale of DDS tones in range [0,1]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.ADRV9002.Tx/DDSScales is inherited from superclass ADI.COMMON.DDS DDSPhases + Phases of DDS tones in range [0,360000]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.ADRV9002.Tx/DDSPhases is inherited from superclass ADI.COMMON.DDS EnableCyclicBuffers + Enable Cyclic Buffers, configures transmit buffers to be cyclic, which makes them continuously repeatHelp for adi.ADRV9002.Tx/EnableCyclicBuffers is inherited from superclass ADI.COMMON.DDS Example Usage %% Configure device tx = adi.adi.ADRV9002.Tx; tx.uri = \"ip:analog.local\"; tx.CenterFrequency = 1e9; tx.DataSource = 'DMA'; tx.EnableCyclicBuffers = true; tx.EnabledChannels = 1; %% Generate tone amplitude = 2^15; frequency = 0.12e6; swv1 = dsp.SineWave(amplitude, frequency); swv1.ComplexOutput = true; swv1.SamplesPerFrame = 2^14; swv1.SampleRate = tx.SamplingRate; y = swv1(); % Send tx(y);","title":"adi.ADRV9002.Tx"},{"location":"sysobjects/adi.ADRV9009.Rx/","text":"The adi.ADRV9009.Rx System object is a signal source that can receive complex data from the ADRV9009. rx = adi.ADRV9009.Rx; rx = adi.ADRV9009.Rx('uri','ip:192.168.2.1'); ADRV9009 Datasheet Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . ADRV9009 . Rx dev = adi . ADRV9009 . Rx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. GainControlMode + specified as one of the following: 'slow_attack' \u2014 For signals with slowly changing power levels 'manual' \u2014 For setting the gain manually with the Gain property GainChannel0 + Channel 0 gain, specified as a scalar from 1 dB to 30 dB. The acceptable minimum and maximum gain setting depends on the center frequency. GainChannel1 + Channel 1 gain, specified as a scalar from 1 dB to 30 dB. The acceptable minimum and maximum gain setting depends on the center frequency. EnableQuadratureTrackingChannel0 + Option to enable quadrature tracking, specified as true or false. When this property is true, IQ imbalance compensation is applied to the input signal. EnableQuadratureTrackingChannel1 + Option to enable quadrature tracking, specified as true or false. When this property is true, IQ imbalance compensation is applied to the input signal. EnableHarmonicDistortionTrackingChannel0 + Option to enable quadrature tracking, specified as true or false. When this property is true, IQ imbalance compensation is applied to the input signal. EnableHarmonicDistortionTrackingChannel1 + Option to enable quadrature tracking, specified as true or false. When this property is true, IQ imbalance compensation is applied to the input signal. EnableQuadratureCalibration + Option to enable quadrature calibration on initialization, specified as true or false. When this property is true, IQ imbalance compensation is applied to the input signal. EnablePhaseCorrection + Option to enable phase tracking, specified as true or false. When this property is true, Phase differences between transceivers will be deterministic across power cycles and LO changes PowerdownChannel0 + Logical which will power down RX channel 0 when set PowerdownChannel1 + Logical which will power down RX channel 1 when set SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance. EnableCustomProfile + Enable use of custom Profile file to set SamplingRate, RFBandwidth, and FIR in datapaths EnableFrequencyHoppingModeCalibration + Option to enable frequency hopping mode VCO calibration, specified as true or false. When this property is true, at initialization VCO calibration lookup table is populated CustomProfileFileName + Path to custom Profile file created from profile wizard CenterFrequency + RF center frequency, specified in Hz as a scalar. The default is 2.4e9. This property is tunable. EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.ADRV9009.Rx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE enIO + If true, connects to libIIO device during simulationHelp for adi.ADRV9009.Rx/enIO is inherited from superclass MATLABSHARED.LIBIIO.BASE Example Usage %% Rx set up rx = adi.adi.ADRV9009.Rx.Rx('uri','ip:analog.local'); rx.CenterFrequency = 1e9; rx.EnabledChannels = 1; %% Run for k=1:10 valid = false; while ~valid [out, valid] = rx(); end end","title":"adi.ADRV9009.Rx"},{"location":"sysobjects/adi.ADRV9009.Tx/","text":"The adi.ADRV9009.Tx System object is a signal sink that can tranmsit complex data from the ADRV9009. tx = adi.ADRV9009.Tx; tx = adi.ADRV9009.Tx('uri','ip:192.168.2.1'); ADRV9009 Datasheet Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . ADRV9009 . Tx dev = adi . ADRV9009 . Tx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. AttenuationChannel0 + Attentuation specified as a scalar from -41.95 to 0 dB with a resolution of 0.05 dB. AttenuationChannel1 + Attentuation specified as a scalar from -41.95 to 0 dB with a resolution of 0.05 dB. EnableQuadratureTrackingChannel0 + Option to enable quadrature tracking, specified as true or false. When this property is true, IQ imbalance compensation is applied to the transmitted signal. EnableQuadratureTrackingChannel1 + Option to enable quadrature tracking, specified as true or false. When this property is true, IQ imbalance compensation is applied to the transmitted signal. EnableLOLeakageTrackingChannel0 + Option to enable quadrature tracking, specified as true or false. When this property is true, LO leakage compensation is applied to the transmitted signal. EnableLOLeakageTrackingChannel1 + Option to enable quadrature tracking, specified as true or false. When this property is true, LO leakage compensation is applied to the transmitted signal. EnableQuadratureCalibration + Option to enable quadrature calibration on initialization, specified as true or false. When this property is true, IQ imbalance compensation is applied to the input signal. EnableLOLeakageCorrection + Option to enable phase tracking, specified as true or false. When this property is true, at initialization LO leakage correction will be applied EnableLOLeakageCorrectionExternal + Option to enable phase tracking, specified as true or false. When this property is true, at initialization LO leakage correction will be applied within an external loopback path. Note this requires external cabling. PowerdownChannel0 + Logical which will power down TX channel 0 when set PowerdownChannel1 + Logical which will power down TX channel 1 when set SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance. EnableCustomProfile + Enable use of custom Profile file to set SamplingRate, RFBandwidth, and FIR in datapaths EnableFrequencyHoppingModeCalibration + Option to enable frequency hopping mode VCO calibration, specified as true or false. When this property is true, at initialization VCO calibration lookup table is populated CustomProfileFileName + Path to custom Profile file created from profile wizard CenterFrequency + RF center frequency, specified in Hz as a scalar. The default is 2.4e9. This property is tunable. EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.ADRV9009.Tx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE enIO + If true, connects to libIIO device during simulationHelp for adi.ADRV9009.Tx/enIO is inherited from superclass MATLABSHARED.LIBIIO.BASE DataSource + Data source, specified as one of the following: 'DMA' \u2014 Specify the host as the source of the data. 'DDS' \u2014 Specify the DDS on the radio hardware as the source of the data. In this case, each channel has two additive tones.Help for adi.ADRV9009.Tx/DataSource is inherited from superclass ADI.COMMON.DDS DDSFrequencies + Frequencies values in Hz of the DDS tone generators. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.ADRV9009.Tx/DDSFrequencies is inherited from superclass ADI.COMMON.DDS DDSScales + Scale of DDS tones in range [0,1]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.ADRV9009.Tx/DDSScales is inherited from superclass ADI.COMMON.DDS DDSPhases + Phases of DDS tones in range [0,360000]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.ADRV9009.Tx/DDSPhases is inherited from superclass ADI.COMMON.DDS EnableCyclicBuffers + Enable Cyclic Buffers, configures transmit buffers to be cyclic, which makes them continuously repeatHelp for adi.ADRV9009.Tx/EnableCyclicBuffers is inherited from superclass ADI.COMMON.DDS Example Usage %% Configure device tx = adi.adi.ADRV9009.Tx; tx.uri = \"ip:analog.local\"; tx.CenterFrequency = 1e9; tx.DataSource = 'DMA'; tx.EnableCyclicBuffers = true; tx.EnabledChannels = 1; %% Generate tone amplitude = 2^15; frequency = 0.12e6; swv1 = dsp.SineWave(amplitude, frequency); swv1.ComplexOutput = true; swv1.SamplesPerFrame = 2^14; swv1.SampleRate = tx.SamplingRate; y = swv1(); % Send tx(y);","title":"adi.ADRV9009.Tx"},{"location":"sysobjects/adi.ADRV9009ZU11EG.Rx/","text":"The adi.ADRV9009ZU11EG.Rx System object is a signal source that can receive complex data from the ADRV9009ZU11EG. rx = adi.ADRV9009ZU11EG.Rx; rx = adi.ADRV9009ZU11EG.Rx('uri','ip:192.168.2.1'); ADRV9009 Datasheet Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . ADRV9009ZU11EG . Rx dev = adi . ADRV9009ZU11EG . Rx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. GainControlModeChipB + specified as one of the following: 'slow_attack' \u2014 For signals with slowly changing power levels 'manual' \u2014 For setting the gain manually with the Gain property GainChannel0ChipB + Channel 0 gain, specified as a scalar from -4 dB to 71 dB. The acceptable minimum and maximum gain setting depends on the center frequency. GainChannel1ChipB + Channel 1 gain, specified as a scalar from -4 dB to 71 dB. The acceptable minimum and maximum gain setting depends on the center frequency. EnableQuadratureTrackingChannel0ChipB + Option to enable quadrature tracking, specified as true or false. When this property is true, IQ imbalance compensation is applied to the input signal. EnableQuadratureTrackingChannel1ChipB + Option to enable quadrature tracking, specified as true or false. When this property is true, IQ imbalance compensation is applied to the input signal. EnableHarmonicDistortionTrackingChannel0ChipB + Option to enable quadrature tracking, specified as true or false. When this property is true, IQ imbalance compensation is applied to the input signal. EnableHarmonicDistortionTrackingChannel1ChipB + Option to enable quadrature tracking, specified as true or false. When this property is true, IQ imbalance compensation is applied to the input signal. EnableQuadratureCalibrationChipB + Option to enable quadrature calibration on initialization, specified as true or false. When this property is true, IQ imbalance compensation is applied to the input signal. EnablePhaseCorrectionChipB + Option to enable phase tracking, specified as true or false. When this property is true, Phase differences between transceivers will be deterministic across power cycles and LO changes PowerdownChannel0ChipB + Logical which will power down RX channel 0 when set PowerdownChannel1ChipB + Logical which will power down RX channel 1 when set CenterFrequencyChipB + RF center frequency, specified in Hz as a scalar. The default is 2.4e9. This property is tunable. EnableFrequencyHoppingModeCalibrationChipB + Option to enable frequency hopping mode VCO calibration, specified as true or false. When this property is true, at initialization VCO calibration lookup table is populated SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance. EnableCustomProfile + Enable use of custom Profile file to set SamplingRate, RFBandwidth, and FIR in datapaths EnableFrequencyHoppingModeCalibration + Option to enable frequency hopping mode VCO calibration, specified as true or false. When this property is true, at initialization VCO calibration lookup table is populated CustomProfileFileName + Path to custom Profile file created from profile wizard CenterFrequency + RF center frequency, specified in Hz as a scalar. The default is 2.4e9. This property is tunable. EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.ADRV9009ZU11EG.Rx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE enIO + If true, connects to libIIO device during simulationHelp for adi.ADRV9009ZU11EG.Rx/enIO is inherited from superclass MATLABSHARED.LIBIIO.BASE devName + Name of the libIIO deviceHelp for adi.ADRV9009ZU11EG.Rx/devName is inherited from superclass MATLABSHARED.LIBIIO.BASE GainControlMode + specified as one of the following: 'slow_attack' \u2014 For signals with slowly changing power levels 'manual' \u2014 For setting the gain manually with the Gain propertyHelp for adi.ADRV9009ZU11EG.Rx/GainControlMode is inherited from superclass ADI.ADRV9009.RX GainChannel0 + Channel 0 gain, specified as a scalar from 1 dB to 30 dB. The acceptable minimum and maximum gain setting depends on the center frequency.Help for adi.ADRV9009ZU11EG.Rx/GainChannel0 is inherited from superclass ADI.ADRV9009.RX GainChannel1 + Channel 1 gain, specified as a scalar from 1 dB to 30 dB. The acceptable minimum and maximum gain setting depends on the center frequency.Help for adi.ADRV9009ZU11EG.Rx/GainChannel1 is inherited from superclass ADI.ADRV9009.RX EnableQuadratureTrackingChannel0 + Option to enable quadrature tracking, specified as true or false. When this property is true, IQ imbalance compensation is applied to the input signal.Help for adi.ADRV9009ZU11EG.Rx/EnableQuadratureTrackingChannel0 is inherited from superclass ADI.ADRV9009.RX EnableQuadratureTrackingChannel1 + Option to enable quadrature tracking, specified as true or false. When this property is true, IQ imbalance compensation is applied to the input signal.Help for adi.ADRV9009ZU11EG.Rx/EnableQuadratureTrackingChannel1 is inherited from superclass ADI.ADRV9009.RX EnableHarmonicDistortionTrackingChannel0 + Option to enable quadrature tracking, specified as true or false. When this property is true, IQ imbalance compensation is applied to the input signal.Help for adi.ADRV9009ZU11EG.Rx/EnableHarmonicDistortionTrackingChannel0 is inherited from superclass ADI.ADRV9009.RX EnableHarmonicDistortionTrackingChannel1 + Option to enable quadrature tracking, specified as true or false. When this property is true, IQ imbalance compensation is applied to the input signal.Help for adi.ADRV9009ZU11EG.Rx/EnableHarmonicDistortionTrackingChannel1 is inherited from superclass ADI.ADRV9009.RX EnableQuadratureCalibration + Option to enable quadrature calibration on initialization, specified as true or false. When this property is true, IQ imbalance compensation is applied to the input signal.Help for adi.ADRV9009ZU11EG.Rx/EnableQuadratureCalibration is inherited from superclass ADI.ADRV9009.RX EnablePhaseCorrection + Option to enable phase tracking, specified as true or false. When this property is true, Phase differences between transceivers will be deterministic across power cycles and LO changesHelp for adi.ADRV9009ZU11EG.Rx/EnablePhaseCorrection is inherited from superclass ADI.ADRV9009.RX PowerdownChannel0 + Logical which will power down RX channel 0 when setHelp for adi.ADRV9009ZU11EG.Rx/PowerdownChannel0 is inherited from superclass ADI.ADRV9009.RX PowerdownChannel1 + Logical which will power down RX channel 1 when setHelp for adi.ADRV9009ZU11EG.Rx/PowerdownChannel1 is inherited from superclass ADI.ADRV9009.RX Example Usage %% Rx set up rx = adi.adi.ADRV9009ZU11EG.Rx.Rx('uri','ip:analog.local'); rx.CenterFrequency = 1e9; rx.EnabledChannels = 1; %% Run for k=1:10 valid = false; while ~valid [out, valid] = rx(); end end","title":"adi.ADRV9009ZU11EG.Rx"},{"location":"sysobjects/adi.ADRV9009ZU11EG.Tx/","text":"The adi.ADRV9009ZU11EG.Tx System object is a signal sink that can tranmsit complex data from the ADRV9009ZU11EG. tx = adi.ADRV9009ZU11EG.Tx; tx = adi.ADRV9009ZU11EG.Tx('uri','ip:192.168.2.1'); ADRV9009 Datasheet Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . ADRV9009ZU11EG . Tx dev = adi . ADRV9009ZU11EG . Tx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. AttenuationChannel0ChipB + Attentuation specified as a scalar from -41.95 to 0 dB with a resolution of 0.05 dB. AttenuationChannel1ChipB + Attentuation specified as a scalar from -41.95 to 0 dB with a resolution of 0.05 dB. EnableQuadratureTrackingChannel0ChipB + Option to enable quadrature tracking, specified as true or false. When this property is true, IQ imbalance compensation is applied to the transmitted signal. EnableQuadratureTrackingChannel1ChipB + Option to enable quadrature tracking, specified as true or false. When this property is true, IQ imbalance compensation is applied to the transmitted signal. EnableLOLeakageTrackingChannel0ChipB + Option to enable quadrature tracking, specified as true or false. When this property is true, LO leakage compensation is applied to the transmitted signal. EnableLOLeakageTrackingChannel1ChipB + Option to enable quadrature tracking, specified as true or false. When this property is true, LO leakage compensation is applied to the transmitted signal. EnableQuadratureCalibrationChipB + Option to enable quadrature calibration on initialization, specified as true or false. When this property is true, IQ imbalance compensation is applied to the input signal. EnableLOLeakageCorrectionChipB + Option to enable phase tracking, specified as true or false. When this property is true, at initialization LO leakage correction will be applied EnableLOLeakageCorrectionExternalChipB + Option to enable phase tracking, specified as true or false. When this property is true, at initialization LO leakage correction will be applied within an external loopback path. Note this requires external cabling. PowerdownChannel0ChipB + Logical which will power down TX channel 0 when set PowerdownChannel1ChipB + Logical which will power down TX channel 1 when set CenterFrequencyChipB + RF center frequency, specified in Hz as a scalar. The default is 2.4e9. This property is tunable. EnableFrequencyHoppingModeCalibrationChipB + Option to enable frequency hopping mode VCO calibration, specified as true or false. When this property is true, at initialization VCO calibration lookup table is populated SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance. EnableCustomProfile + Enable use of custom Profile file to set SamplingRate, RFBandwidth, and FIR in datapaths EnableFrequencyHoppingModeCalibration + Option to enable frequency hopping mode VCO calibration, specified as true or false. When this property is true, at initialization VCO calibration lookup table is populated CustomProfileFileName + Path to custom Profile file created from profile wizard CenterFrequency + RF center frequency, specified in Hz as a scalar. The default is 2.4e9. This property is tunable. EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.ADRV9009ZU11EG.Tx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE enIO + If true, connects to libIIO device during simulationHelp for adi.ADRV9009ZU11EG.Tx/enIO is inherited from superclass MATLABSHARED.LIBIIO.BASE devName + Name of the libIIO deviceHelp for adi.ADRV9009ZU11EG.Tx/devName is inherited from superclass MATLABSHARED.LIBIIO.BASE AttenuationChannel0 + Attentuation specified as a scalar from -41.95 to 0 dB with a resolution of 0.05 dB.Help for adi.ADRV9009ZU11EG.Tx/AttenuationChannel0 is inherited from superclass ADI.ADRV9009.TX AttenuationChannel1 + Attentuation specified as a scalar from -41.95 to 0 dB with a resolution of 0.05 dB.Help for adi.ADRV9009ZU11EG.Tx/AttenuationChannel1 is inherited from superclass ADI.ADRV9009.TX EnableQuadratureTrackingChannel0 + Option to enable quadrature tracking, specified as true or false. When this property is true, IQ imbalance compensation is applied to the transmitted signal.Help for adi.ADRV9009ZU11EG.Tx/EnableQuadratureTrackingChannel0 is inherited from superclass ADI.ADRV9009.TX EnableQuadratureTrackingChannel1 + Option to enable quadrature tracking, specified as true or false. When this property is true, IQ imbalance compensation is applied to the transmitted signal.Help for adi.ADRV9009ZU11EG.Tx/EnableQuadratureTrackingChannel1 is inherited from superclass ADI.ADRV9009.TX EnableLOLeakageTrackingChannel0 + Option to enable quadrature tracking, specified as true or false. When this property is true, LO leakage compensation is applied to the transmitted signal.Help for adi.ADRV9009ZU11EG.Tx/EnableLOLeakageTrackingChannel0 is inherited from superclass ADI.ADRV9009.TX EnableLOLeakageTrackingChannel1 + Option to enable quadrature tracking, specified as true or false. When this property is true, LO leakage compensation is applied to the transmitted signal.Help for adi.ADRV9009ZU11EG.Tx/EnableLOLeakageTrackingChannel1 is inherited from superclass ADI.ADRV9009.TX EnableQuadratureCalibration + Option to enable quadrature calibration on initialization, specified as true or false. When this property is true, IQ imbalance compensation is applied to the input signal.Help for adi.ADRV9009ZU11EG.Tx/EnableQuadratureCalibration is inherited from superclass ADI.ADRV9009.TX EnableLOLeakageCorrection + Option to enable phase tracking, specified as true or false. When this property is true, at initialization LO leakage correction will be appliedHelp for adi.ADRV9009ZU11EG.Tx/EnableLOLeakageCorrection is inherited from superclass ADI.ADRV9009.TX EnableLOLeakageCorrectionExternal + Option to enable phase tracking, specified as true or false. When this property is true, at initialization LO leakage correction will be applied within an external loopback path. Note this requires external cabling.Help for adi.ADRV9009ZU11EG.Tx/EnableLOLeakageCorrectionExternal is inherited from superclass ADI.ADRV9009.TX PowerdownChannel0 + Logical which will power down TX channel 0 when setHelp for adi.ADRV9009ZU11EG.Tx/PowerdownChannel0 is inherited from superclass ADI.ADRV9009.TX PowerdownChannel1 + Logical which will power down TX channel 1 when setHelp for adi.ADRV9009ZU11EG.Tx/PowerdownChannel1 is inherited from superclass ADI.ADRV9009.TX DataSource + Data source, specified as one of the following: 'DMA' \u2014 Specify the host as the source of the data. 'DDS' \u2014 Specify the DDS on the radio hardware as the source of the data. In this case, each channel has two additive tones.Help for adi.ADRV9009ZU11EG.Tx/DataSource is inherited from superclass ADI.COMMON.DDS DDSFrequencies + Frequencies values in Hz of the DDS tone generators. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.ADRV9009ZU11EG.Tx/DDSFrequencies is inherited from superclass ADI.COMMON.DDS DDSScales + Scale of DDS tones in range [0,1]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.ADRV9009ZU11EG.Tx/DDSScales is inherited from superclass ADI.COMMON.DDS DDSPhases + Phases of DDS tones in range [0,360000]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.ADRV9009ZU11EG.Tx/DDSPhases is inherited from superclass ADI.COMMON.DDS EnableCyclicBuffers + Enable Cyclic Buffers, configures transmit buffers to be cyclic, which makes them continuously repeatHelp for adi.ADRV9009ZU11EG.Tx/EnableCyclicBuffers is inherited from superclass ADI.COMMON.DDS Example Usage %% Configure device tx = adi.adi.ADRV9009ZU11EG.Tx; tx.uri = \"ip:analog.local\"; tx.CenterFrequency = 1e9; tx.DataSource = 'DMA'; tx.EnableCyclicBuffers = true; tx.EnabledChannels = 1; %% Generate tone amplitude = 2^15; frequency = 0.12e6; swv1 = dsp.SineWave(amplitude, frequency); swv1.ComplexOutput = true; swv1.SamplesPerFrame = 2^14; swv1.SampleRate = tx.SamplingRate; y = swv1(); % Send tx(y);","title":"adi.ADRV9009ZU11EG.Tx"},{"location":"sysobjects/adi.ADRV9361Z7035.Rx/","text":"The adi.ADRV9361Z7035.Rx System object is a signal source that can receive complex data from the ADRV9361Z7035. rx = adi.ADRV9361Z7035.Rx; rx = adi.ADRV9361Z7035.Rx('uri','ip:192.168.2.1'); Product Page Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . ADRV9361Z7035 . Rx dev = adi . ADRV9361Z7035 . Rx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. CenterFrequency + RF center frequency, specified in Hz as a scalar. The default is 2.4e9. This property is tunable.Help for adi.ADRV9361Z7035.Rx/CenterFrequency is inherited from superclass ADI.AD9361.RX SamplingRate + Baseband sampling rate in Hz, specified as a scalar from 65105 to 61.44e6 samples per second.Help for adi.ADRV9361Z7035.Rx/SamplingRate is inherited from superclass ADI.AD9361.RX RFBandwidth + RF Bandwidth of front-end analog filter in Hz, specified as a scalar from 200 kHz to 56 MHz.Help for adi.ADRV9361Z7035.Rx/RFBandwidth is inherited from superclass ADI.AD9361.RX GainControlModeChannel0 + specified as one of the following: 'slow_attack' \u2014 For signals with slowly changing power levels 'fast_attack' \u2014 For signals with rapidly changing power levels 'manual' \u2014 For setting the gain manually with the Gain property 'hybrid' \u2014 For configuring hybrid AGC modeHelp for adi.ADRV9361Z7035.Rx/GainControlModeChannel0 is inherited from superclass ADI.AD9361.RX GainChannel0 + Channel 0 gain, specified as a scalar from -3 dB to 71 dB. The acceptable minimum and maximum gain setting depends on the center frequency.Help for adi.ADRV9361Z7035.Rx/GainChannel0 is inherited from superclass ADI.AD9361.RX GainControlModeChannel1 + specified as one of the following: 'slow_attack' \u2014 For signals with slowly changing power levels 'fast_attack' \u2014 For signals with rapidly changing power levels 'manual' \u2014 For setting the gain manually with the Gain property 'hybrid' \u2014 For configuring hybrid AGC modeHelp for adi.ADRV9361Z7035.Rx/GainControlModeChannel1 is inherited from superclass ADI.AD9361.RX GainChannel1 + Channel 1 gain, specified as a scalar from -3 dB to 71 dB. The acceptable minimum and maximum gain setting depends on the center frequency.Help for adi.ADRV9361Z7035.Rx/GainChannel1 is inherited from superclass ADI.AD9361.RX LoopbackMode + Option to set digital loopback mode, specified as 0, 1 or 2. Allows either to digitally loopback TX data into the RX path or vice versa. Value | Mode --------------------------- 0 | Disable 1 | Digital TX -> Digital RX 2 | RF RX -> RF TX Help for adi.ADRV9361Z7035.Rx/LoopbackMode is inherited from superclass ADI.AD9361.RX EnableQuadratureTracking + Option to enable quadrature tracking, specified as true or false. When this property is true, IQ imbalance compensation is applied to the input signal.Help for adi.ADRV9361Z7035.Rx/EnableQuadratureTracking is inherited from superclass ADI.AD9361.RX EnableRFDCTracking + Option to enable RF DC tracking, specified as true or false. When this property is true, an RF DC blocking filter is applied to the input signal.Help for adi.ADRV9361Z7035.Rx/EnableRFDCTracking is inherited from superclass ADI.AD9361.RX EnableBasebandDCTracking + Option to enable baseband DC tracking, specified as true or false. When this property is true, a baseband DC blocking filter is applied to the input signal.Help for adi.ADRV9361Z7035.Rx/EnableBasebandDCTracking is inherited from superclass ADI.AD9361.RX RFPortSelect + 'A_BALANCED' 'B_BALANCED' 'C_BALANCED' 'A_N' 'A_P' 'B_N' 'B_P' 'C_N' 'C_P' 'TX_MONITOR1' 'TX_MONITOR2' 'TX_MONITOR1_2'Help for adi.ADRV9361Z7035.Rx/RFPortSelect is inherited from superclass ADI.AD9361.RX SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance. EnableCustomFilter + Enable use of custom filter file to set SamplingRate, RFBandwidth, and FIR in datapaths CustomFilterFileName + Path to custom filter file created from filter wizard EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.ADRV9361Z7035.Rx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE enIO + If true, connects to libIIO device during simulationHelp for adi.ADRV9361Z7035.Rx/enIO is inherited from superclass MATLABSHARED.LIBIIO.BASE Example Usage %% Rx set up rx = adi.adi.ADRV9361Z7035.Rx.Rx('uri','ip:analog.local'); rx.CenterFrequency = 1e9; rx.EnabledChannels = 1; %% Run for k=1:10 valid = false; while ~valid [out, valid] = rx(); end end","title":"adi.ADRV9361Z7035.Rx"},{"location":"sysobjects/adi.ADRV9361Z7035.Tx/","text":"The adi.ADRV9361Z7035.Tx System object is a signal source that can send complex data to the FMComms2. tx = adi.ADRV9361Z7035.Tx; tx = adi.ADRV9361Z7035.Tx('uri','ip:192.168.2.1'); Product Page Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . ADRV9361Z7035 . Tx dev = adi . ADRV9361Z7035 . Tx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. CenterFrequency + RF center frequency, specified in Hz as a scalar. The default is 2.4e9. This property is tunable.Help for adi.ADRV9361Z7035.Tx/CenterFrequency is inherited from superclass ADI.AD9361.TX SamplingRate + Baseband sampling rate in Hz, specified as a scalar from 65105 to 61.44e6 samples per second.Help for adi.ADRV9361Z7035.Tx/SamplingRate is inherited from superclass ADI.AD9361.TX RFBandwidth + RF Bandwidth of front-end analog filter in Hz, specified as a scalar from 200 kHz to 56 MHz.Help for adi.ADRV9361Z7035.Tx/RFBandwidth is inherited from superclass ADI.AD9361.TX AttenuationChannel0 + Attentuation specified as a scalar from -89.75 to 0 dB with a resolution of 0.25 dB.Help for adi.ADRV9361Z7035.Tx/AttenuationChannel0 is inherited from superclass ADI.AD9361.TX AttenuationChannel1 + Attentuation specified as a scalar from -89.75 to 0 dB with a resolution of 0.25 dB.Help for adi.ADRV9361Z7035.Tx/AttenuationChannel1 is inherited from superclass ADI.AD9361.TX RFPortSelect + 'A' 'B'Help for adi.ADRV9361Z7035.Tx/RFPortSelect is inherited from superclass ADI.AD9361.TX SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance. EnableCustomFilter + Enable use of custom filter file to set SamplingRate, RFBandwidth, and FIR in datapaths CustomFilterFileName + Path to custom filter file created from filter wizard EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.ADRV9361Z7035.Tx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE enIO + If true, connects to libIIO device during simulationHelp for adi.ADRV9361Z7035.Tx/enIO is inherited from superclass MATLABSHARED.LIBIIO.BASE DataSource + Data source, specified as one of the following: 'DMA' \u2014 Specify the host as the source of the data. 'DDS' \u2014 Specify the DDS on the radio hardware as the source of the data. In this case, each channel has two additive tones.Help for adi.ADRV9361Z7035.Tx/DataSource is inherited from superclass ADI.COMMON.DDS DDSFrequencies + Frequencies values in Hz of the DDS tone generators. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.ADRV9361Z7035.Tx/DDSFrequencies is inherited from superclass ADI.COMMON.DDS DDSScales + Scale of DDS tones in range [0,1]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.ADRV9361Z7035.Tx/DDSScales is inherited from superclass ADI.COMMON.DDS DDSPhases + Phases of DDS tones in range [0,360000]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.ADRV9361Z7035.Tx/DDSPhases is inherited from superclass ADI.COMMON.DDS EnableCyclicBuffers + Enable Cyclic Buffers, configures transmit buffers to be cyclic, which makes them continuously repeatHelp for adi.ADRV9361Z7035.Tx/EnableCyclicBuffers is inherited from superclass ADI.COMMON.DDS Example Usage %% Configure device tx = adi.adi.ADRV9361Z7035.Tx; tx.uri = \"ip:analog.local\"; tx.CenterFrequency = 1e9; tx.DataSource = 'DMA'; tx.EnableCyclicBuffers = true; tx.EnabledChannels = 1; %% Generate tone amplitude = 2^15; frequency = 0.12e6; swv1 = dsp.SineWave(amplitude, frequency); swv1.ComplexOutput = true; swv1.SamplesPerFrame = 2^14; swv1.SampleRate = tx.SamplingRate; y = swv1(); % Send tx(y);","title":"adi.ADRV9361Z7035.Tx"},{"location":"sysobjects/adi.ADRV9364Z7020.Rx/","text":"The adi.ADRV9364Z7020.Tx System object is a signal source that can send complex data to the FMComms4. tx = adi.ADRV9364Z7020.Tx; tx = adi.ADRV9364Z7020.Tx('uri','ip:192.168.2.1'); Product Page Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . ADRV9364Z7020 . Rx dev = adi . ADRV9364Z7020 . Rx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. CenterFrequency + RF center frequency, specified in Hz as a scalar. The default is 2.4e9. This property is tunable.Help for adi.ADRV9364Z7020.Rx/CenterFrequency is inherited from superclass ADI.AD9361.RX SamplingRate + Baseband sampling rate in Hz, specified as a scalar from 65105 to 61.44e6 samples per second.Help for adi.ADRV9364Z7020.Rx/SamplingRate is inherited from superclass ADI.AD9361.RX RFBandwidth + RF Bandwidth of front-end analog filter in Hz, specified as a scalar from 200 kHz to 56 MHz.Help for adi.ADRV9364Z7020.Rx/RFBandwidth is inherited from superclass ADI.AD9361.RX GainControlModeChannel0 + specified as one of the following: 'slow_attack' \u2014 For signals with slowly changing power levels 'fast_attack' \u2014 For signals with rapidly changing power levels 'manual' \u2014 For setting the gain manually with the Gain property 'hybrid' \u2014 For configuring hybrid AGC modeHelp for adi.ADRV9364Z7020.Rx/GainControlModeChannel0 is inherited from superclass ADI.AD9361.RX GainChannel0 + Channel 0 gain, specified as a scalar from -3 dB to 71 dB. The acceptable minimum and maximum gain setting depends on the center frequency.Help for adi.ADRV9364Z7020.Rx/GainChannel0 is inherited from superclass ADI.AD9361.RX GainControlModeChannel1 + specified as one of the following: 'slow_attack' \u2014 For signals with slowly changing power levels 'fast_attack' \u2014 For signals with rapidly changing power levels 'manual' \u2014 For setting the gain manually with the Gain property 'hybrid' \u2014 For configuring hybrid AGC modeHelp for adi.ADRV9364Z7020.Rx/GainControlModeChannel1 is inherited from superclass ADI.AD9361.RX GainChannel1 + Channel 1 gain, specified as a scalar from -3 dB to 71 dB. The acceptable minimum and maximum gain setting depends on the center frequency.Help for adi.ADRV9364Z7020.Rx/GainChannel1 is inherited from superclass ADI.AD9361.RX LoopbackMode + Option to set digital loopback mode, specified as 0, 1 or 2. Allows either to digitally loopback TX data into the RX path or vice versa. Value | Mode --------------------------- 0 | Disable 1 | Digital TX -> Digital RX 2 | RF RX -> RF TX Help for adi.ADRV9364Z7020.Rx/LoopbackMode is inherited from superclass ADI.AD9361.RX EnableQuadratureTracking + Option to enable quadrature tracking, specified as true or false. When this property is true, IQ imbalance compensation is applied to the input signal.Help for adi.ADRV9364Z7020.Rx/EnableQuadratureTracking is inherited from superclass ADI.AD9361.RX EnableRFDCTracking + Option to enable RF DC tracking, specified as true or false. When this property is true, an RF DC blocking filter is applied to the input signal.Help for adi.ADRV9364Z7020.Rx/EnableRFDCTracking is inherited from superclass ADI.AD9361.RX EnableBasebandDCTracking + Option to enable baseband DC tracking, specified as true or false. When this property is true, a baseband DC blocking filter is applied to the input signal.Help for adi.ADRV9364Z7020.Rx/EnableBasebandDCTracking is inherited from superclass ADI.AD9361.RX RFPortSelect + 'A_BALANCED' 'B_BALANCED' 'C_BALANCED' 'A_N' 'A_P' 'B_N' 'B_P' 'C_N' 'C_P' 'TX_MONITOR1' 'TX_MONITOR2' 'TX_MONITOR1_2'Help for adi.ADRV9364Z7020.Rx/RFPortSelect is inherited from superclass ADI.AD9361.RX SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance. EnableCustomFilter + Enable use of custom filter file to set SamplingRate, RFBandwidth, and FIR in datapaths CustomFilterFileName + Path to custom filter file created from filter wizard EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.ADRV9364Z7020.Rx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE enIO + If true, connects to libIIO device during simulationHelp for adi.ADRV9364Z7020.Rx/enIO is inherited from superclass MATLABSHARED.LIBIIO.BASE Example Usage %% Rx set up rx = adi.adi.ADRV9364Z7020.Rx.Rx('uri','ip:analog.local'); rx.CenterFrequency = 1e9; rx.EnabledChannels = 1; %% Run for k=1:10 valid = false; while ~valid [out, valid] = rx(); end end","title":"adi.ADRV9364Z7020.Rx"},{"location":"sysobjects/adi.ADRV9364Z7020.Tx/","text":"The adi.ADRV9364Z7020.Tx System object is a signal sink that can transmit complex data from the FMComms4. tx = adi.ADRV9364Z7020.Tx; tx = adi.ADRV9364Z7020.Tx('uri','ip:192.168.2.1'); Product Page Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . ADRV9364Z7020 . Tx dev = adi . ADRV9364Z7020 . Tx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. CenterFrequency + RF center frequency, specified in Hz as a scalar. The default is 2.4e9. This property is tunable.Help for adi.ADRV9364Z7020.Tx/CenterFrequency is inherited from superclass ADI.AD9361.TX SamplingRate + Baseband sampling rate in Hz, specified as a scalar from 65105 to 61.44e6 samples per second.Help for adi.ADRV9364Z7020.Tx/SamplingRate is inherited from superclass ADI.AD9361.TX RFBandwidth + RF Bandwidth of front-end analog filter in Hz, specified as a scalar from 200 kHz to 56 MHz.Help for adi.ADRV9364Z7020.Tx/RFBandwidth is inherited from superclass ADI.AD9361.TX AttenuationChannel0 + Attentuation specified as a scalar from -89.75 to 0 dB with a resolution of 0.25 dB.Help for adi.ADRV9364Z7020.Tx/AttenuationChannel0 is inherited from superclass ADI.AD9361.TX AttenuationChannel1 + Attentuation specified as a scalar from -89.75 to 0 dB with a resolution of 0.25 dB.Help for adi.ADRV9364Z7020.Tx/AttenuationChannel1 is inherited from superclass ADI.AD9361.TX RFPortSelect + 'A' 'B'Help for adi.ADRV9364Z7020.Tx/RFPortSelect is inherited from superclass ADI.AD9361.TX SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance. EnableCustomFilter + Enable use of custom filter file to set SamplingRate, RFBandwidth, and FIR in datapaths CustomFilterFileName + Path to custom filter file created from filter wizard EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.ADRV9364Z7020.Tx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE enIO + If true, connects to libIIO device during simulationHelp for adi.ADRV9364Z7020.Tx/enIO is inherited from superclass MATLABSHARED.LIBIIO.BASE DataSource + Data source, specified as one of the following: 'DMA' \u2014 Specify the host as the source of the data. 'DDS' \u2014 Specify the DDS on the radio hardware as the source of the data. In this case, each channel has two additive tones.Help for adi.ADRV9364Z7020.Tx/DataSource is inherited from superclass ADI.COMMON.DDS DDSFrequencies + Frequencies values in Hz of the DDS tone generators. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.ADRV9364Z7020.Tx/DDSFrequencies is inherited from superclass ADI.COMMON.DDS DDSScales + Scale of DDS tones in range [0,1]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.ADRV9364Z7020.Tx/DDSScales is inherited from superclass ADI.COMMON.DDS DDSPhases + Phases of DDS tones in range [0,360000]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.ADRV9364Z7020.Tx/DDSPhases is inherited from superclass ADI.COMMON.DDS EnableCyclicBuffers + Enable Cyclic Buffers, configures transmit buffers to be cyclic, which makes them continuously repeatHelp for adi.ADRV9364Z7020.Tx/EnableCyclicBuffers is inherited from superclass ADI.COMMON.DDS Example Usage %% Configure device tx = adi.adi.ADRV9364Z7020.Tx; tx.uri = \"ip:analog.local\"; tx.CenterFrequency = 1e9; tx.DataSource = 'DMA'; tx.EnableCyclicBuffers = true; tx.EnabledChannels = 1; %% Generate tone amplitude = 2^15; frequency = 0.12e6; swv1 = dsp.SineWave(amplitude, frequency); swv1.ComplexOutput = true; swv1.SamplesPerFrame = 2^14; swv1.SampleRate = tx.SamplingRate; y = swv1(); % Send tx(y);","title":"adi.ADRV9364Z7020.Tx"},{"location":"sysobjects/adi.ADRV9371.Rx/","text":"The adi.ADRV9371.Rx System object is a signal source that can receive complex data from the ADRV9371. rx = adi.AD9371.Rx; rx = adi.AD9371.Rx('uri','ip:192.168.2.1'); Product Page Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . ADRV9371 . Rx dev = adi . ADRV9371 . Rx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. GainControlMode + specified as one of the following: 'slow_attack' \u2014 For signals with slowly changing power levels 'fast_attack' \u2014 For signals with rapidly changing power levels 'manual' \u2014 For setting the gain manually with the Gain property 'hybrid' \u2014 For configuring hybrid AGC modeHelp for adi.ADRV9371.Rx/GainControlMode is inherited from superclass ADI.AD9371.RX GainChannel0 + Channel 0 gain, specified as a scalar from -4 dB to 71 dB. The acceptable minimum and maximum gain setting depends on the center frequency.Help for adi.ADRV9371.Rx/GainChannel0 is inherited from superclass ADI.AD9371.RX GainChannel1 + Channel 1 gain, specified as a scalar from -4 dB to 71 dB. The acceptable minimum and maximum gain setting depends on the center frequency.Help for adi.ADRV9371.Rx/GainChannel1 is inherited from superclass ADI.AD9371.RX LoopbackMode + Option to set digital loopback mode, specified as 0 or 1. Allows digital loopback of TX data into the RX path. Value | Mode --------------------------- 0 | Disable 1 | EnableHelp for adi.ADRV9371.Rx/LoopbackMode is inherited from superclass ADI.AD9371.RX EnableQuadratureTrackingChannel0 + Option to enable quadrature tracking, specified as true or false. When this property is true, IQ imbalance compensation is applied to the input signal.Help for adi.ADRV9371.Rx/EnableQuadratureTrackingChannel0 is inherited from superclass ADI.AD9371.RX EnableQuadratureTrackingChannel1 + Option to enable quadrature tracking, specified as true or false. When this property is true, IQ imbalance compensation is applied to the input signal.Help for adi.ADRV9371.Rx/EnableQuadratureTrackingChannel1 is inherited from superclass ADI.AD9371.RX SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance. EnableCustomProfile + Enable use of custom Profile file to set SamplingRate, RFBandwidth, and FIR in datapaths CustomProfileFileName + Path to custom Profile file created from profile wizard CenterFrequency + RF center frequency, specified in Hz as a scalar. The default is 2.4e9. This property is tunable. EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.ADRV9371.Rx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE enIO + If true, connects to libIIO device during simulationHelp for adi.ADRV9371.Rx/enIO is inherited from superclass MATLABSHARED.LIBIIO.BASE Example Usage %% Rx set up rx = adi.adi.ADRV9371.Rx.Rx('uri','ip:analog.local'); rx.CenterFrequency = 1e9; rx.EnabledChannels = 1; %% Run for k=1:10 valid = false; while ~valid [out, valid] = rx(); end end","title":"adi.ADRV9371.Rx"},{"location":"sysobjects/adi.ADRV9371.Tx/","text":"The adi.ADRV9371.Tx System object is a signal sink that can send complex data to the ADRV9371. tx = adi.AD9371.Tx; tx = adi.AD9371.Tx('uri','ip:192.168.2.1'); Product Page Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . ADRV9371 . Tx dev = adi . ADRV9371 . Tx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. AttenuationChannel0 + Attentuation specified as a scalar from -89.75 to 0 dB with a resolution of 0.25 dB.Help for adi.ADRV9371.Tx/AttenuationChannel0 is inherited from superclass ADI.AD9371.TX AttenuationChannel1 + Attentuation specified as a scalar from -89.75 to 0 dB with a resolution of 0.25 dB.Help for adi.ADRV9371.Tx/AttenuationChannel1 is inherited from superclass ADI.AD9371.TX SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance. EnableCustomProfile + Enable use of custom Profile file to set SamplingRate, RFBandwidth, and FIR in datapaths CustomProfileFileName + Path to custom Profile file created from profile wizard CenterFrequency + RF center frequency, specified in Hz as a scalar. The default is 2.4e9. This property is tunable. EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.ADRV9371.Tx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE enIO + If true, connects to libIIO device during simulationHelp for adi.ADRV9371.Tx/enIO is inherited from superclass MATLABSHARED.LIBIIO.BASE DataSource + Data source, specified as one of the following: 'DMA' \u2014 Specify the host as the source of the data. 'DDS' \u2014 Specify the DDS on the radio hardware as the source of the data. In this case, each channel has two additive tones.Help for adi.ADRV9371.Tx/DataSource is inherited from superclass ADI.COMMON.DDS DDSFrequencies + Frequencies values in Hz of the DDS tone generators. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.ADRV9371.Tx/DDSFrequencies is inherited from superclass ADI.COMMON.DDS DDSScales + Scale of DDS tones in range [0,1]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.ADRV9371.Tx/DDSScales is inherited from superclass ADI.COMMON.DDS DDSPhases + Phases of DDS tones in range [0,360000]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.ADRV9371.Tx/DDSPhases is inherited from superclass ADI.COMMON.DDS EnableCyclicBuffers + Enable Cyclic Buffers, configures transmit buffers to be cyclic, which makes them continuously repeatHelp for adi.ADRV9371.Tx/EnableCyclicBuffers is inherited from superclass ADI.COMMON.DDS Example Usage %% Configure device tx = adi.adi.ADRV9371.Tx; tx.uri = \"ip:analog.local\"; tx.CenterFrequency = 1e9; tx.DataSource = 'DMA'; tx.EnableCyclicBuffers = true; tx.EnabledChannels = 1; %% Generate tone amplitude = 2^15; frequency = 0.12e6; swv1 = dsp.SineWave(amplitude, frequency); swv1.ComplexOutput = true; swv1.SamplesPerFrame = 2^14; swv1.SampleRate = tx.SamplingRate; y = swv1(); % Send tx(y);","title":"adi.ADRV9371.Tx"},{"location":"sysobjects/adi.FMComms2.Rx/","text":"The adi.FMComms2.Rx System object is a signal source that can receive complex data from the FMComms2. rx = adi.FMComms2.Rx; rx = adi.FMComms2.Rx('uri','ip:192.168.2.1'); Product Page Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . FMComms2 . Rx dev = adi . FMComms2 . Rx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. CenterFrequency + RF center frequency, specified in Hz as a scalar. The default is 2.4e9. This property is tunable.Help for adi.FMComms2.Rx/CenterFrequency is inherited from superclass ADI.AD9361.RX SamplingRate + Baseband sampling rate in Hz, specified as a scalar from 65105 to 61.44e6 samples per second.Help for adi.FMComms2.Rx/SamplingRate is inherited from superclass ADI.AD9361.RX RFBandwidth + RF Bandwidth of front-end analog filter in Hz, specified as a scalar from 200 kHz to 56 MHz.Help for adi.FMComms2.Rx/RFBandwidth is inherited from superclass ADI.AD9361.RX GainControlModeChannel0 + specified as one of the following: 'slow_attack' \u2014 For signals with slowly changing power levels 'fast_attack' \u2014 For signals with rapidly changing power levels 'manual' \u2014 For setting the gain manually with the Gain property 'hybrid' \u2014 For configuring hybrid AGC modeHelp for adi.FMComms2.Rx/GainControlModeChannel0 is inherited from superclass ADI.AD9361.RX GainChannel0 + Channel 0 gain, specified as a scalar from -3 dB to 71 dB. The acceptable minimum and maximum gain setting depends on the center frequency.Help for adi.FMComms2.Rx/GainChannel0 is inherited from superclass ADI.AD9361.RX GainControlModeChannel1 + specified as one of the following: 'slow_attack' \u2014 For signals with slowly changing power levels 'fast_attack' \u2014 For signals with rapidly changing power levels 'manual' \u2014 For setting the gain manually with the Gain property 'hybrid' \u2014 For configuring hybrid AGC modeHelp for adi.FMComms2.Rx/GainControlModeChannel1 is inherited from superclass ADI.AD9361.RX GainChannel1 + Channel 1 gain, specified as a scalar from -3 dB to 71 dB. The acceptable minimum and maximum gain setting depends on the center frequency.Help for adi.FMComms2.Rx/GainChannel1 is inherited from superclass ADI.AD9361.RX LoopbackMode + Option to set digital loopback mode, specified as 0, 1 or 2. Allows either to digitally loopback TX data into the RX path or vice versa. Value | Mode --------------------------- 0 | Disable 1 | Digital TX -> Digital RX 2 | RF RX -> RF TX Help for adi.FMComms2.Rx/LoopbackMode is inherited from superclass ADI.AD9361.RX EnableQuadratureTracking + Option to enable quadrature tracking, specified as true or false. When this property is true, IQ imbalance compensation is applied to the input signal.Help for adi.FMComms2.Rx/EnableQuadratureTracking is inherited from superclass ADI.AD9361.RX EnableRFDCTracking + Option to enable RF DC tracking, specified as true or false. When this property is true, an RF DC blocking filter is applied to the input signal.Help for adi.FMComms2.Rx/EnableRFDCTracking is inherited from superclass ADI.AD9361.RX EnableBasebandDCTracking + Option to enable baseband DC tracking, specified as true or false. When this property is true, a baseband DC blocking filter is applied to the input signal.Help for adi.FMComms2.Rx/EnableBasebandDCTracking is inherited from superclass ADI.AD9361.RX RFPortSelect + 'A_BALANCED' 'B_BALANCED' 'C_BALANCED' 'A_N' 'A_P' 'B_N' 'B_P' 'C_N' 'C_P' 'TX_MONITOR1' 'TX_MONITOR2' 'TX_MONITOR1_2'Help for adi.FMComms2.Rx/RFPortSelect is inherited from superclass ADI.AD9361.RX SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance. EnableCustomFilter + Enable use of custom filter file to set SamplingRate, RFBandwidth, and FIR in datapaths CustomFilterFileName + Path to custom filter file created from filter wizard EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.FMComms2.Rx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE enIO + If true, connects to libIIO device during simulationHelp for adi.FMComms2.Rx/enIO is inherited from superclass MATLABSHARED.LIBIIO.BASE Example Usage %% Rx set up rx = adi.adi.FMComms2.Rx.Rx('uri','ip:analog.local'); rx.CenterFrequency = 1e9; rx.EnabledChannels = 1; %% Run for k=1:10 valid = false; while ~valid [out, valid] = rx(); end end","title":"adi.FMComms2.Rx"},{"location":"sysobjects/adi.FMComms2.Tx/","text":"The adi.FMComms2.Tx System object is a signal source that can send complex data to the FMComms2. tx = adi.FMComms2.Tx; tx = adi.FMComms2.Tx('uri','ip:192.168.2.1'); Product Page Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . FMComms2 . Tx dev = adi . FMComms2 . Tx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. CenterFrequency + RF center frequency, specified in Hz as a scalar. The default is 2.4e9. This property is tunable.Help for adi.FMComms2.Tx/CenterFrequency is inherited from superclass ADI.AD9361.TX SamplingRate + Baseband sampling rate in Hz, specified as a scalar from 65105 to 61.44e6 samples per second.Help for adi.FMComms2.Tx/SamplingRate is inherited from superclass ADI.AD9361.TX RFBandwidth + RF Bandwidth of front-end analog filter in Hz, specified as a scalar from 200 kHz to 56 MHz.Help for adi.FMComms2.Tx/RFBandwidth is inherited from superclass ADI.AD9361.TX AttenuationChannel0 + Attentuation specified as a scalar from -89.75 to 0 dB with a resolution of 0.25 dB.Help for adi.FMComms2.Tx/AttenuationChannel0 is inherited from superclass ADI.AD9361.TX AttenuationChannel1 + Attentuation specified as a scalar from -89.75 to 0 dB with a resolution of 0.25 dB.Help for adi.FMComms2.Tx/AttenuationChannel1 is inherited from superclass ADI.AD9361.TX RFPortSelect + 'A' 'B'Help for adi.FMComms2.Tx/RFPortSelect is inherited from superclass ADI.AD9361.TX SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance. EnableCustomFilter + Enable use of custom filter file to set SamplingRate, RFBandwidth, and FIR in datapaths CustomFilterFileName + Path to custom filter file created from filter wizard EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.FMComms2.Tx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE enIO + If true, connects to libIIO device during simulationHelp for adi.FMComms2.Tx/enIO is inherited from superclass MATLABSHARED.LIBIIO.BASE DataSource + Data source, specified as one of the following: 'DMA' \u2014 Specify the host as the source of the data. 'DDS' \u2014 Specify the DDS on the radio hardware as the source of the data. In this case, each channel has two additive tones.Help for adi.FMComms2.Tx/DataSource is inherited from superclass ADI.COMMON.DDS DDSFrequencies + Frequencies values in Hz of the DDS tone generators. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.FMComms2.Tx/DDSFrequencies is inherited from superclass ADI.COMMON.DDS DDSScales + Scale of DDS tones in range [0,1]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.FMComms2.Tx/DDSScales is inherited from superclass ADI.COMMON.DDS DDSPhases + Phases of DDS tones in range [0,360000]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.FMComms2.Tx/DDSPhases is inherited from superclass ADI.COMMON.DDS EnableCyclicBuffers + Enable Cyclic Buffers, configures transmit buffers to be cyclic, which makes them continuously repeatHelp for adi.FMComms2.Tx/EnableCyclicBuffers is inherited from superclass ADI.COMMON.DDS Example Usage %% Configure device tx = adi.adi.FMComms2.Tx; tx.uri = \"ip:analog.local\"; tx.CenterFrequency = 1e9; tx.DataSource = 'DMA'; tx.EnableCyclicBuffers = true; tx.EnabledChannels = 1; %% Generate tone amplitude = 2^15; frequency = 0.12e6; swv1 = dsp.SineWave(amplitude, frequency); swv1.ComplexOutput = true; swv1.SamplesPerFrame = 2^14; swv1.SampleRate = tx.SamplingRate; y = swv1(); % Send tx(y);","title":"adi.FMComms2.Tx"},{"location":"sysobjects/adi.FMComms3.Rx/","text":"The adi.FMComms3.Rx System object is a signal source that can receive complex data from the FMComms2. rx = adi.FMComms3.Rx; rx = adi.FMComms3.Rx('uri','ip:192.168.2.1'); Product Page Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . FMComms3 . Rx dev = adi . FMComms3 . Rx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. CenterFrequency + RF center frequency, specified in Hz as a scalar. The default is 2.4e9. This property is tunable.Help for adi.FMComms3.Rx/CenterFrequency is inherited from superclass ADI.AD9361.RX SamplingRate + Baseband sampling rate in Hz, specified as a scalar from 65105 to 61.44e6 samples per second.Help for adi.FMComms3.Rx/SamplingRate is inherited from superclass ADI.AD9361.RX RFBandwidth + RF Bandwidth of front-end analog filter in Hz, specified as a scalar from 200 kHz to 56 MHz.Help for adi.FMComms3.Rx/RFBandwidth is inherited from superclass ADI.AD9361.RX GainControlModeChannel0 + specified as one of the following: 'slow_attack' \u2014 For signals with slowly changing power levels 'fast_attack' \u2014 For signals with rapidly changing power levels 'manual' \u2014 For setting the gain manually with the Gain property 'hybrid' \u2014 For configuring hybrid AGC modeHelp for adi.FMComms3.Rx/GainControlModeChannel0 is inherited from superclass ADI.AD9361.RX GainChannel0 + Channel 0 gain, specified as a scalar from -3 dB to 71 dB. The acceptable minimum and maximum gain setting depends on the center frequency.Help for adi.FMComms3.Rx/GainChannel0 is inherited from superclass ADI.AD9361.RX GainControlModeChannel1 + specified as one of the following: 'slow_attack' \u2014 For signals with slowly changing power levels 'fast_attack' \u2014 For signals with rapidly changing power levels 'manual' \u2014 For setting the gain manually with the Gain property 'hybrid' \u2014 For configuring hybrid AGC modeHelp for adi.FMComms3.Rx/GainControlModeChannel1 is inherited from superclass ADI.AD9361.RX GainChannel1 + Channel 1 gain, specified as a scalar from -3 dB to 71 dB. The acceptable minimum and maximum gain setting depends on the center frequency.Help for adi.FMComms3.Rx/GainChannel1 is inherited from superclass ADI.AD9361.RX LoopbackMode + Option to set digital loopback mode, specified as 0, 1 or 2. Allows either to digitally loopback TX data into the RX path or vice versa. Value | Mode --------------------------- 0 | Disable 1 | Digital TX -> Digital RX 2 | RF RX -> RF TX Help for adi.FMComms3.Rx/LoopbackMode is inherited from superclass ADI.AD9361.RX EnableQuadratureTracking + Option to enable quadrature tracking, specified as true or false. When this property is true, IQ imbalance compensation is applied to the input signal.Help for adi.FMComms3.Rx/EnableQuadratureTracking is inherited from superclass ADI.AD9361.RX EnableRFDCTracking + Option to enable RF DC tracking, specified as true or false. When this property is true, an RF DC blocking filter is applied to the input signal.Help for adi.FMComms3.Rx/EnableRFDCTracking is inherited from superclass ADI.AD9361.RX EnableBasebandDCTracking + Option to enable baseband DC tracking, specified as true or false. When this property is true, a baseband DC blocking filter is applied to the input signal.Help for adi.FMComms3.Rx/EnableBasebandDCTracking is inherited from superclass ADI.AD9361.RX RFPortSelect + 'A_BALANCED' 'B_BALANCED' 'C_BALANCED' 'A_N' 'A_P' 'B_N' 'B_P' 'C_N' 'C_P' 'TX_MONITOR1' 'TX_MONITOR2' 'TX_MONITOR1_2'Help for adi.FMComms3.Rx/RFPortSelect is inherited from superclass ADI.AD9361.RX SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance. EnableCustomFilter + Enable use of custom filter file to set SamplingRate, RFBandwidth, and FIR in datapaths CustomFilterFileName + Path to custom filter file created from filter wizard EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.FMComms3.Rx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE enIO + If true, connects to libIIO device during simulationHelp for adi.FMComms3.Rx/enIO is inherited from superclass MATLABSHARED.LIBIIO.BASE Example Usage %% Rx set up rx = adi.adi.FMComms3.Rx.Rx('uri','ip:analog.local'); rx.CenterFrequency = 1e9; rx.EnabledChannels = 1; %% Run for k=1:10 valid = false; while ~valid [out, valid] = rx(); end end","title":"adi.FMComms3.Rx"},{"location":"sysobjects/adi.FMComms3.Tx/","text":"The adi.FMComms3.Tx System object is a signal source that can send complex data to the FMComms2. tx = adi.FMComms3.Tx; tx = adi.FMComms3.Tx('uri','ip:192.168.2.1'); Product Page Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . FMComms3 . Tx dev = adi . FMComms3 . Tx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. CenterFrequency + RF center frequency, specified in Hz as a scalar. The default is 2.4e9. This property is tunable.Help for adi.FMComms3.Tx/CenterFrequency is inherited from superclass ADI.AD9361.TX SamplingRate + Baseband sampling rate in Hz, specified as a scalar from 65105 to 61.44e6 samples per second.Help for adi.FMComms3.Tx/SamplingRate is inherited from superclass ADI.AD9361.TX RFBandwidth + RF Bandwidth of front-end analog filter in Hz, specified as a scalar from 200 kHz to 56 MHz.Help for adi.FMComms3.Tx/RFBandwidth is inherited from superclass ADI.AD9361.TX AttenuationChannel0 + Attentuation specified as a scalar from -89.75 to 0 dB with a resolution of 0.25 dB.Help for adi.FMComms3.Tx/AttenuationChannel0 is inherited from superclass ADI.AD9361.TX AttenuationChannel1 + Attentuation specified as a scalar from -89.75 to 0 dB with a resolution of 0.25 dB.Help for adi.FMComms3.Tx/AttenuationChannel1 is inherited from superclass ADI.AD9361.TX RFPortSelect + 'A' 'B'Help for adi.FMComms3.Tx/RFPortSelect is inherited from superclass ADI.AD9361.TX SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance. EnableCustomFilter + Enable use of custom filter file to set SamplingRate, RFBandwidth, and FIR in datapaths CustomFilterFileName + Path to custom filter file created from filter wizard EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.FMComms3.Tx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE enIO + If true, connects to libIIO device during simulationHelp for adi.FMComms3.Tx/enIO is inherited from superclass MATLABSHARED.LIBIIO.BASE DataSource + Data source, specified as one of the following: 'DMA' \u2014 Specify the host as the source of the data. 'DDS' \u2014 Specify the DDS on the radio hardware as the source of the data. In this case, each channel has two additive tones.Help for adi.FMComms3.Tx/DataSource is inherited from superclass ADI.COMMON.DDS DDSFrequencies + Frequencies values in Hz of the DDS tone generators. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.FMComms3.Tx/DDSFrequencies is inherited from superclass ADI.COMMON.DDS DDSScales + Scale of DDS tones in range [0,1]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.FMComms3.Tx/DDSScales is inherited from superclass ADI.COMMON.DDS DDSPhases + Phases of DDS tones in range [0,360000]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.FMComms3.Tx/DDSPhases is inherited from superclass ADI.COMMON.DDS EnableCyclicBuffers + Enable Cyclic Buffers, configures transmit buffers to be cyclic, which makes them continuously repeatHelp for adi.FMComms3.Tx/EnableCyclicBuffers is inherited from superclass ADI.COMMON.DDS Example Usage %% Configure device tx = adi.adi.FMComms3.Tx; tx.uri = \"ip:analog.local\"; tx.CenterFrequency = 1e9; tx.DataSource = 'DMA'; tx.EnableCyclicBuffers = true; tx.EnabledChannels = 1; %% Generate tone amplitude = 2^15; frequency = 0.12e6; swv1 = dsp.SineWave(amplitude, frequency); swv1.ComplexOutput = true; swv1.SamplesPerFrame = 2^14; swv1.SampleRate = tx.SamplingRate; y = swv1(); % Send tx(y);","title":"adi.FMComms3.Tx"},{"location":"sysobjects/adi.FMComms4.Rx/","text":"The adi.FMComms4.Tx System object is a signal source that can send complex data to the FMComms4. tx = adi.FMComms4.Tx; tx = adi.FMComms4.Tx('uri','ip:192.168.2.1'); Product Page Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . FMComms4 . Rx dev = adi . FMComms4 . Rx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. CenterFrequency + RF center frequency, specified in Hz as a scalar. The default is 2.4e9. This property is tunable.Help for adi.FMComms4.Rx/CenterFrequency is inherited from superclass ADI.AD9361.RX SamplingRate + Baseband sampling rate in Hz, specified as a scalar from 65105 to 61.44e6 samples per second.Help for adi.FMComms4.Rx/SamplingRate is inherited from superclass ADI.AD9361.RX RFBandwidth + RF Bandwidth of front-end analog filter in Hz, specified as a scalar from 200 kHz to 56 MHz.Help for adi.FMComms4.Rx/RFBandwidth is inherited from superclass ADI.AD9361.RX GainControlModeChannel0 + specified as one of the following: 'slow_attack' \u2014 For signals with slowly changing power levels 'fast_attack' \u2014 For signals with rapidly changing power levels 'manual' \u2014 For setting the gain manually with the Gain property 'hybrid' \u2014 For configuring hybrid AGC modeHelp for adi.FMComms4.Rx/GainControlModeChannel0 is inherited from superclass ADI.AD9361.RX GainChannel0 + Channel 0 gain, specified as a scalar from -3 dB to 71 dB. The acceptable minimum and maximum gain setting depends on the center frequency.Help for adi.FMComms4.Rx/GainChannel0 is inherited from superclass ADI.AD9361.RX GainControlModeChannel1 + specified as one of the following: 'slow_attack' \u2014 For signals with slowly changing power levels 'fast_attack' \u2014 For signals with rapidly changing power levels 'manual' \u2014 For setting the gain manually with the Gain property 'hybrid' \u2014 For configuring hybrid AGC modeHelp for adi.FMComms4.Rx/GainControlModeChannel1 is inherited from superclass ADI.AD9361.RX GainChannel1 + Channel 1 gain, specified as a scalar from -3 dB to 71 dB. The acceptable minimum and maximum gain setting depends on the center frequency.Help for adi.FMComms4.Rx/GainChannel1 is inherited from superclass ADI.AD9361.RX LoopbackMode + Option to set digital loopback mode, specified as 0, 1 or 2. Allows either to digitally loopback TX data into the RX path or vice versa. Value | Mode --------------------------- 0 | Disable 1 | Digital TX -> Digital RX 2 | RF RX -> RF TX Help for adi.FMComms4.Rx/LoopbackMode is inherited from superclass ADI.AD9361.RX EnableQuadratureTracking + Option to enable quadrature tracking, specified as true or false. When this property is true, IQ imbalance compensation is applied to the input signal.Help for adi.FMComms4.Rx/EnableQuadratureTracking is inherited from superclass ADI.AD9361.RX EnableRFDCTracking + Option to enable RF DC tracking, specified as true or false. When this property is true, an RF DC blocking filter is applied to the input signal.Help for adi.FMComms4.Rx/EnableRFDCTracking is inherited from superclass ADI.AD9361.RX EnableBasebandDCTracking + Option to enable baseband DC tracking, specified as true or false. When this property is true, a baseband DC blocking filter is applied to the input signal.Help for adi.FMComms4.Rx/EnableBasebandDCTracking is inherited from superclass ADI.AD9361.RX RFPortSelect + 'A_BALANCED' 'B_BALANCED' 'C_BALANCED' 'A_N' 'A_P' 'B_N' 'B_P' 'C_N' 'C_P' 'TX_MONITOR1' 'TX_MONITOR2' 'TX_MONITOR1_2'Help for adi.FMComms4.Rx/RFPortSelect is inherited from superclass ADI.AD9361.RX SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance. EnableCustomFilter + Enable use of custom filter file to set SamplingRate, RFBandwidth, and FIR in datapaths CustomFilterFileName + Path to custom filter file created from filter wizard EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.FMComms4.Rx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE enIO + If true, connects to libIIO device during simulationHelp for adi.FMComms4.Rx/enIO is inherited from superclass MATLABSHARED.LIBIIO.BASE Example Usage %% Rx set up rx = adi.adi.FMComms4.Rx.Rx('uri','ip:analog.local'); rx.CenterFrequency = 1e9; rx.EnabledChannels = 1; %% Run for k=1:10 valid = false; while ~valid [out, valid] = rx(); end end","title":"adi.FMComms4.Rx"},{"location":"sysobjects/adi.FMComms4.Tx/","text":"The adi.FMComms4.Tx System object is a signal sink that can transmit complex data from the FMComms4. tx = adi.FMComms4.Tx; tx = adi.FMComms4.Tx('uri','ip:192.168.2.1'); Product Page Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . FMComms4 . Tx dev = adi . FMComms4 . Tx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. CenterFrequency + RF center frequency, specified in Hz as a scalar. The default is 2.4e9. This property is tunable.Help for adi.FMComms4.Tx/CenterFrequency is inherited from superclass ADI.AD9361.TX SamplingRate + Baseband sampling rate in Hz, specified as a scalar from 65105 to 61.44e6 samples per second.Help for adi.FMComms4.Tx/SamplingRate is inherited from superclass ADI.AD9361.TX RFBandwidth + RF Bandwidth of front-end analog filter in Hz, specified as a scalar from 200 kHz to 56 MHz.Help for adi.FMComms4.Tx/RFBandwidth is inherited from superclass ADI.AD9361.TX AttenuationChannel0 + Attentuation specified as a scalar from -89.75 to 0 dB with a resolution of 0.25 dB.Help for adi.FMComms4.Tx/AttenuationChannel0 is inherited from superclass ADI.AD9361.TX AttenuationChannel1 + Attentuation specified as a scalar from -89.75 to 0 dB with a resolution of 0.25 dB.Help for adi.FMComms4.Tx/AttenuationChannel1 is inherited from superclass ADI.AD9361.TX RFPortSelect + 'A' 'B'Help for adi.FMComms4.Tx/RFPortSelect is inherited from superclass ADI.AD9361.TX SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance. EnableCustomFilter + Enable use of custom filter file to set SamplingRate, RFBandwidth, and FIR in datapaths CustomFilterFileName + Path to custom filter file created from filter wizard EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.FMComms4.Tx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE enIO + If true, connects to libIIO device during simulationHelp for adi.FMComms4.Tx/enIO is inherited from superclass MATLABSHARED.LIBIIO.BASE DataSource + Data source, specified as one of the following: 'DMA' \u2014 Specify the host as the source of the data. 'DDS' \u2014 Specify the DDS on the radio hardware as the source of the data. In this case, each channel has two additive tones.Help for adi.FMComms4.Tx/DataSource is inherited from superclass ADI.COMMON.DDS DDSFrequencies + Frequencies values in Hz of the DDS tone generators. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.FMComms4.Tx/DDSFrequencies is inherited from superclass ADI.COMMON.DDS DDSScales + Scale of DDS tones in range [0,1]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.FMComms4.Tx/DDSScales is inherited from superclass ADI.COMMON.DDS DDSPhases + Phases of DDS tones in range [0,360000]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.FMComms4.Tx/DDSPhases is inherited from superclass ADI.COMMON.DDS EnableCyclicBuffers + Enable Cyclic Buffers, configures transmit buffers to be cyclic, which makes them continuously repeatHelp for adi.FMComms4.Tx/EnableCyclicBuffers is inherited from superclass ADI.COMMON.DDS Example Usage %% Configure device tx = adi.adi.FMComms4.Tx; tx.uri = \"ip:analog.local\"; tx.CenterFrequency = 1e9; tx.DataSource = 'DMA'; tx.EnableCyclicBuffers = true; tx.EnabledChannels = 1; %% Generate tone amplitude = 2^15; frequency = 0.12e6; swv1 = dsp.SineWave(amplitude, frequency); swv1.ComplexOutput = true; swv1.SamplesPerFrame = 2^14; swv1.SampleRate = tx.SamplingRate; y = swv1(); % Send tx(y);","title":"adi.FMComms4.Tx"},{"location":"sysobjects/adi.FMComms8.Rx/","text":"The adi.FMComms8.Tx System object is a signal source that can send complex data to the FMComms8. tx = adi.FMComms8.Tx; tx = adi.FMComms8.Tx('uri','ip:192.168.2.1'); Product Page Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . FMComms8 . Rx dev = adi . FMComms8 . Rx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. GainControlModeChipB + specified as one of the following: 'slow_attack' \u2014 For signals with slowly changing power levels 'manual' \u2014 For setting the gain manually with the Gain propertyHelp for adi.FMComms8.Rx/GainControlModeChipB is inherited from superclass ADI.ADRV9009ZU11EG.RX GainChannel0ChipB + Channel 0 gain, specified as a scalar from -4 dB to 71 dB. The acceptable minimum and maximum gain setting depends on the center frequency.Help for adi.FMComms8.Rx/GainChannel0ChipB is inherited from superclass ADI.ADRV9009ZU11EG.RX GainChannel1ChipB + Channel 1 gain, specified as a scalar from -4 dB to 71 dB. The acceptable minimum and maximum gain setting depends on the center frequency.Help for adi.FMComms8.Rx/GainChannel1ChipB is inherited from superclass ADI.ADRV9009ZU11EG.RX EnableQuadratureTrackingChannel0ChipB + Option to enable quadrature tracking, specified as true or false. When this property is true, IQ imbalance compensation is applied to the input signal.Help for adi.FMComms8.Rx/EnableQuadratureTrackingChannel0ChipB is inherited from superclass ADI.ADRV9009ZU11EG.RX EnableQuadratureTrackingChannel1ChipB + Option to enable quadrature tracking, specified as true or false. When this property is true, IQ imbalance compensation is applied to the input signal.Help for adi.FMComms8.Rx/EnableQuadratureTrackingChannel1ChipB is inherited from superclass ADI.ADRV9009ZU11EG.RX EnableHarmonicDistortionTrackingChannel0ChipB + Option to enable quadrature tracking, specified as true or false. When this property is true, IQ imbalance compensation is applied to the input signal.Help for adi.FMComms8.Rx/EnableHarmonicDistortionTrackingChannel0ChipB is inherited from superclass ADI.ADRV9009ZU11EG.RX EnableHarmonicDistortionTrackingChannel1ChipB + Option to enable quadrature tracking, specified as true or false. When this property is true, IQ imbalance compensation is applied to the input signal.Help for adi.FMComms8.Rx/EnableHarmonicDistortionTrackingChannel1ChipB is inherited from superclass ADI.ADRV9009ZU11EG.RX EnableQuadratureCalibrationChipB + Option to enable quadrature calibration on initialization, specified as true or false. When this property is true, IQ imbalance compensation is applied to the input signal.Help for adi.FMComms8.Rx/EnableQuadratureCalibrationChipB is inherited from superclass ADI.ADRV9009ZU11EG.RX EnablePhaseCorrectionChipB + Option to enable phase tracking, specified as true or false. When this property is true, Phase differences between transceivers will be deterministic across power cycles and LO changesHelp for adi.FMComms8.Rx/EnablePhaseCorrectionChipB is inherited from superclass ADI.ADRV9009ZU11EG.RX PowerdownChannel0ChipB + Logical which will power down RX channel 0 when setHelp for adi.FMComms8.Rx/PowerdownChannel0ChipB is inherited from superclass ADI.ADRV9009ZU11EG.RX PowerdownChannel1ChipB + Logical which will power down RX channel 1 when setHelp for adi.FMComms8.Rx/PowerdownChannel1ChipB is inherited from superclass ADI.ADRV9009ZU11EG.RX CenterFrequencyChipB + RF center frequency, specified in Hz as a scalar. The default is 2.4e9. This property is tunable. EnableFrequencyHoppingModeCalibrationChipB + Option to enable frequency hopping mode VCO calibration, specified as true or false. When this property is true, at initialization VCO calibration lookup table is populated SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance. EnableCustomProfile + Enable use of custom Profile file to set SamplingRate, RFBandwidth, and FIR in datapaths EnableFrequencyHoppingModeCalibration + Option to enable frequency hopping mode VCO calibration, specified as true or false. When this property is true, at initialization VCO calibration lookup table is populated CustomProfileFileName + Path to custom Profile file created from profile wizard CenterFrequency + RF center frequency, specified in Hz as a scalar. The default is 2.4e9. This property is tunable. EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.FMComms8.Rx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE enIO + If true, connects to libIIO device during simulationHelp for adi.FMComms8.Rx/enIO is inherited from superclass MATLABSHARED.LIBIIO.BASE devName + Name of the libIIO deviceHelp for adi.FMComms8.Rx/devName is inherited from superclass MATLABSHARED.LIBIIO.BASE GainControlMode + specified as one of the following: 'slow_attack' \u2014 For signals with slowly changing power levels 'manual' \u2014 For setting the gain manually with the Gain propertyHelp for adi.FMComms8.Rx/GainControlMode is inherited from superclass ADI.ADRV9009.RX GainChannel0 + Channel 0 gain, specified as a scalar from 1 dB to 30 dB. The acceptable minimum and maximum gain setting depends on the center frequency.Help for adi.FMComms8.Rx/GainChannel0 is inherited from superclass ADI.ADRV9009.RX GainChannel1 + Channel 1 gain, specified as a scalar from 1 dB to 30 dB. The acceptable minimum and maximum gain setting depends on the center frequency.Help for adi.FMComms8.Rx/GainChannel1 is inherited from superclass ADI.ADRV9009.RX EnableQuadratureTrackingChannel0 + Option to enable quadrature tracking, specified as true or false. When this property is true, IQ imbalance compensation is applied to the input signal.Help for adi.FMComms8.Rx/EnableQuadratureTrackingChannel0 is inherited from superclass ADI.ADRV9009.RX EnableQuadratureTrackingChannel1 + Option to enable quadrature tracking, specified as true or false. When this property is true, IQ imbalance compensation is applied to the input signal.Help for adi.FMComms8.Rx/EnableQuadratureTrackingChannel1 is inherited from superclass ADI.ADRV9009.RX EnableHarmonicDistortionTrackingChannel0 + Option to enable quadrature tracking, specified as true or false. When this property is true, IQ imbalance compensation is applied to the input signal.Help for adi.FMComms8.Rx/EnableHarmonicDistortionTrackingChannel0 is inherited from superclass ADI.ADRV9009.RX EnableHarmonicDistortionTrackingChannel1 + Option to enable quadrature tracking, specified as true or false. When this property is true, IQ imbalance compensation is applied to the input signal.Help for adi.FMComms8.Rx/EnableHarmonicDistortionTrackingChannel1 is inherited from superclass ADI.ADRV9009.RX EnableQuadratureCalibration + Option to enable quadrature calibration on initialization, specified as true or false. When this property is true, IQ imbalance compensation is applied to the input signal.Help for adi.FMComms8.Rx/EnableQuadratureCalibration is inherited from superclass ADI.ADRV9009.RX EnablePhaseCorrection + Option to enable phase tracking, specified as true or false. When this property is true, Phase differences between transceivers will be deterministic across power cycles and LO changesHelp for adi.FMComms8.Rx/EnablePhaseCorrection is inherited from superclass ADI.ADRV9009.RX PowerdownChannel0 + Logical which will power down RX channel 0 when setHelp for adi.FMComms8.Rx/PowerdownChannel0 is inherited from superclass ADI.ADRV9009.RX PowerdownChannel1 + Logical which will power down RX channel 1 when setHelp for adi.FMComms8.Rx/PowerdownChannel1 is inherited from superclass ADI.ADRV9009.RX Example Usage %% Rx set up rx = adi.adi.FMComms8.Rx.Rx('uri','ip:analog.local'); rx.CenterFrequency = 1e9; rx.EnabledChannels = 1; %% Run for k=1:10 valid = false; while ~valid [out, valid] = rx(); end end","title":"adi.FMComms8.Rx"},{"location":"sysobjects/adi.FMComms8.Tx/","text":"The adi.FMComms8.Tx System object is a signal sink that can transmit complex data from the FMComms8. tx = adi.FMComms8.Tx; tx = adi.FMComms8.Tx('uri','ip:192.168.2.1'); Product Page Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . FMComms8 . Tx dev = adi . FMComms8 . Tx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. AttenuationChannel0ChipB + Attentuation specified as a scalar from -41.95 to 0 dB with a resolution of 0.05 dB.Help for adi.FMComms8.Tx/AttenuationChannel0ChipB is inherited from superclass ADI.ADRV9009ZU11EG.TX AttenuationChannel1ChipB + Attentuation specified as a scalar from -41.95 to 0 dB with a resolution of 0.05 dB.Help for adi.FMComms8.Tx/AttenuationChannel1ChipB is inherited from superclass ADI.ADRV9009ZU11EG.TX EnableQuadratureTrackingChannel0ChipB + Option to enable quadrature tracking, specified as true or false. When this property is true, IQ imbalance compensation is applied to the transmitted signal.Help for adi.FMComms8.Tx/EnableQuadratureTrackingChannel0ChipB is inherited from superclass ADI.ADRV9009ZU11EG.TX EnableQuadratureTrackingChannel1ChipB + Option to enable quadrature tracking, specified as true or false. When this property is true, IQ imbalance compensation is applied to the transmitted signal.Help for adi.FMComms8.Tx/EnableQuadratureTrackingChannel1ChipB is inherited from superclass ADI.ADRV9009ZU11EG.TX EnableLOLeakageTrackingChannel0ChipB + Option to enable quadrature tracking, specified as true or false. When this property is true, LO leakage compensation is applied to the transmitted signal.Help for adi.FMComms8.Tx/EnableLOLeakageTrackingChannel0ChipB is inherited from superclass ADI.ADRV9009ZU11EG.TX EnableLOLeakageTrackingChannel1ChipB + Option to enable quadrature tracking, specified as true or false. When this property is true, LO leakage compensation is applied to the transmitted signal.Help for adi.FMComms8.Tx/EnableLOLeakageTrackingChannel1ChipB is inherited from superclass ADI.ADRV9009ZU11EG.TX EnableQuadratureCalibrationChipB + Option to enable quadrature calibration on initialization, specified as true or false. When this property is true, IQ imbalance compensation is applied to the input signal.Help for adi.FMComms8.Tx/EnableQuadratureCalibrationChipB is inherited from superclass ADI.ADRV9009ZU11EG.TX EnableLOLeakageCorrectionChipB + Option to enable phase tracking, specified as true or false. When this property is true, at initialization LO leakage correction will be appliedHelp for adi.FMComms8.Tx/EnableLOLeakageCorrectionChipB is inherited from superclass ADI.ADRV9009ZU11EG.TX EnableLOLeakageCorrectionExternalChipB + Option to enable phase tracking, specified as true or false. When this property is true, at initialization LO leakage correction will be applied within an external loopback path. Note this requires external cabling.Help for adi.FMComms8.Tx/EnableLOLeakageCorrectionExternalChipB is inherited from superclass ADI.ADRV9009ZU11EG.TX PowerdownChannel0ChipB + Logical which will power down TX channel 0 when setHelp for adi.FMComms8.Tx/PowerdownChannel0ChipB is inherited from superclass ADI.ADRV9009ZU11EG.TX PowerdownChannel1ChipB + Logical which will power down TX channel 1 when setHelp for adi.FMComms8.Tx/PowerdownChannel1ChipB is inherited from superclass ADI.ADRV9009ZU11EG.TX CenterFrequencyChipB + RF center frequency, specified in Hz as a scalar. The default is 2.4e9. This property is tunable. EnableFrequencyHoppingModeCalibrationChipB + Option to enable frequency hopping mode VCO calibration, specified as true or false. When this property is true, at initialization VCO calibration lookup table is populated SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance. EnableCustomProfile + Enable use of custom Profile file to set SamplingRate, RFBandwidth, and FIR in datapaths EnableFrequencyHoppingModeCalibration + Option to enable frequency hopping mode VCO calibration, specified as true or false. When this property is true, at initialization VCO calibration lookup table is populated CustomProfileFileName + Path to custom Profile file created from profile wizard CenterFrequency + RF center frequency, specified in Hz as a scalar. The default is 2.4e9. This property is tunable. EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.FMComms8.Tx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE enIO + If true, connects to libIIO device during simulationHelp for adi.FMComms8.Tx/enIO is inherited from superclass MATLABSHARED.LIBIIO.BASE devName + Name of the libIIO deviceHelp for adi.FMComms8.Tx/devName is inherited from superclass MATLABSHARED.LIBIIO.BASE AttenuationChannel0 + Attentuation specified as a scalar from -41.95 to 0 dB with a resolution of 0.05 dB.Help for adi.FMComms8.Tx/AttenuationChannel0 is inherited from superclass ADI.ADRV9009.TX AttenuationChannel1 + Attentuation specified as a scalar from -41.95 to 0 dB with a resolution of 0.05 dB.Help for adi.FMComms8.Tx/AttenuationChannel1 is inherited from superclass ADI.ADRV9009.TX EnableQuadratureTrackingChannel0 + Option to enable quadrature tracking, specified as true or false. When this property is true, IQ imbalance compensation is applied to the transmitted signal.Help for adi.FMComms8.Tx/EnableQuadratureTrackingChannel0 is inherited from superclass ADI.ADRV9009.TX EnableQuadratureTrackingChannel1 + Option to enable quadrature tracking, specified as true or false. When this property is true, IQ imbalance compensation is applied to the transmitted signal.Help for adi.FMComms8.Tx/EnableQuadratureTrackingChannel1 is inherited from superclass ADI.ADRV9009.TX EnableLOLeakageTrackingChannel0 + Option to enable quadrature tracking, specified as true or false. When this property is true, LO leakage compensation is applied to the transmitted signal.Help for adi.FMComms8.Tx/EnableLOLeakageTrackingChannel0 is inherited from superclass ADI.ADRV9009.TX EnableLOLeakageTrackingChannel1 + Option to enable quadrature tracking, specified as true or false. When this property is true, LO leakage compensation is applied to the transmitted signal.Help for adi.FMComms8.Tx/EnableLOLeakageTrackingChannel1 is inherited from superclass ADI.ADRV9009.TX EnableQuadratureCalibration + Option to enable quadrature calibration on initialization, specified as true or false. When this property is true, IQ imbalance compensation is applied to the input signal.Help for adi.FMComms8.Tx/EnableQuadratureCalibration is inherited from superclass ADI.ADRV9009.TX EnableLOLeakageCorrection + Option to enable phase tracking, specified as true or false. When this property is true, at initialization LO leakage correction will be appliedHelp for adi.FMComms8.Tx/EnableLOLeakageCorrection is inherited from superclass ADI.ADRV9009.TX EnableLOLeakageCorrectionExternal + Option to enable phase tracking, specified as true or false. When this property is true, at initialization LO leakage correction will be applied within an external loopback path. Note this requires external cabling.Help for adi.FMComms8.Tx/EnableLOLeakageCorrectionExternal is inherited from superclass ADI.ADRV9009.TX PowerdownChannel0 + Logical which will power down TX channel 0 when setHelp for adi.FMComms8.Tx/PowerdownChannel0 is inherited from superclass ADI.ADRV9009.TX PowerdownChannel1 + Logical which will power down TX channel 1 when setHelp for adi.FMComms8.Tx/PowerdownChannel1 is inherited from superclass ADI.ADRV9009.TX DataSource + Data source, specified as one of the following: 'DMA' \u2014 Specify the host as the source of the data. 'DDS' \u2014 Specify the DDS on the radio hardware as the source of the data. In this case, each channel has two additive tones.Help for adi.FMComms8.Tx/DataSource is inherited from superclass ADI.COMMON.DDS DDSFrequencies + Frequencies values in Hz of the DDS tone generators. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.FMComms8.Tx/DDSFrequencies is inherited from superclass ADI.COMMON.DDS DDSScales + Scale of DDS tones in range [0,1]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.FMComms8.Tx/DDSScales is inherited from superclass ADI.COMMON.DDS DDSPhases + Phases of DDS tones in range [0,360000]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.FMComms8.Tx/DDSPhases is inherited from superclass ADI.COMMON.DDS EnableCyclicBuffers + Enable Cyclic Buffers, configures transmit buffers to be cyclic, which makes them continuously repeatHelp for adi.FMComms8.Tx/EnableCyclicBuffers is inherited from superclass ADI.COMMON.DDS Example Usage %% Configure device tx = adi.adi.FMComms8.Tx; tx.uri = \"ip:analog.local\"; tx.CenterFrequency = 1e9; tx.DataSource = 'DMA'; tx.EnableCyclicBuffers = true; tx.EnabledChannels = 1; %% Generate tone amplitude = 2^15; frequency = 0.12e6; swv1 = dsp.SineWave(amplitude, frequency); swv1.ComplexOutput = true; swv1.SamplesPerFrame = 2^14; swv1.SampleRate = tx.SamplingRate; y = swv1(); % Send tx(y);","title":"adi.FMComms8.Tx"},{"location":"sysobjects/adi.PackRF.Rx/","text":"Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . PackRF . Rx dev = adi . PackRF . Rx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. CenterFrequency + RF center frequency, specified in Hz as a scalar. The default is 2.4e9. This property is tunable.Help for adi.PackRF.Rx/CenterFrequency is inherited from superclass ADI.AD9361.RX SamplingRate + Baseband sampling rate in Hz, specified as a scalar from 65105 to 61.44e6 samples per second.Help for adi.PackRF.Rx/SamplingRate is inherited from superclass ADI.AD9361.RX RFBandwidth + RF Bandwidth of front-end analog filter in Hz, specified as a scalar from 200 kHz to 56 MHz.Help for adi.PackRF.Rx/RFBandwidth is inherited from superclass ADI.AD9361.RX GainControlModeChannel0 + specified as one of the following: 'slow_attack' \u2014 For signals with slowly changing power levels 'fast_attack' \u2014 For signals with rapidly changing power levels 'manual' \u2014 For setting the gain manually with the Gain property 'hybrid' \u2014 For configuring hybrid AGC modeHelp for adi.PackRF.Rx/GainControlModeChannel0 is inherited from superclass ADI.AD9361.RX GainChannel0 + Channel 0 gain, specified as a scalar from -3 dB to 71 dB. The acceptable minimum and maximum gain setting depends on the center frequency.Help for adi.PackRF.Rx/GainChannel0 is inherited from superclass ADI.AD9361.RX GainControlModeChannel1 + specified as one of the following: 'slow_attack' \u2014 For signals with slowly changing power levels 'fast_attack' \u2014 For signals with rapidly changing power levels 'manual' \u2014 For setting the gain manually with the Gain property 'hybrid' \u2014 For configuring hybrid AGC modeHelp for adi.PackRF.Rx/GainControlModeChannel1 is inherited from superclass ADI.AD9361.RX GainChannel1 + Channel 1 gain, specified as a scalar from -3 dB to 71 dB. The acceptable minimum and maximum gain setting depends on the center frequency.Help for adi.PackRF.Rx/GainChannel1 is inherited from superclass ADI.AD9361.RX LoopbackMode + Option to set digital loopback mode, specified as 0, 1 or 2. Allows either to digitally loopback TX data into the RX path or vice versa. Value | Mode --------------------------- 0 | Disable 1 | Digital TX -> Digital RX 2 | RF RX -> RF TX Help for adi.PackRF.Rx/LoopbackMode is inherited from superclass ADI.AD9361.RX EnableQuadratureTracking + Option to enable quadrature tracking, specified as true or false. When this property is true, IQ imbalance compensation is applied to the input signal.Help for adi.PackRF.Rx/EnableQuadratureTracking is inherited from superclass ADI.AD9361.RX EnableRFDCTracking + Option to enable RF DC tracking, specified as true or false. When this property is true, an RF DC blocking filter is applied to the input signal.Help for adi.PackRF.Rx/EnableRFDCTracking is inherited from superclass ADI.AD9361.RX EnableBasebandDCTracking + Option to enable baseband DC tracking, specified as true or false. When this property is true, a baseband DC blocking filter is applied to the input signal.Help for adi.PackRF.Rx/EnableBasebandDCTracking is inherited from superclass ADI.AD9361.RX RFPortSelect + 'A_BALANCED' 'B_BALANCED' 'C_BALANCED' 'A_N' 'A_P' 'B_N' 'B_P' 'C_N' 'C_P' 'TX_MONITOR1' 'TX_MONITOR2' 'TX_MONITOR1_2'Help for adi.PackRF.Rx/RFPortSelect is inherited from superclass ADI.AD9361.RX SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance. EnableCustomFilter + Enable use of custom filter file to set SamplingRate, RFBandwidth, and FIR in datapaths CustomFilterFileName + Path to custom filter file created from filter wizard EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.PackRF.Rx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE enIO + If true, connects to libIIO device during simulationHelp for adi.PackRF.Rx/enIO is inherited from superclass MATLABSHARED.LIBIIO.BASE Example Usage %% Rx set up rx = adi.adi.PackRF.Rx.Rx('uri','ip:analog.local'); rx.CenterFrequency = 1e9; rx.EnabledChannels = 1; %% Run for k=1:10 valid = false; while ~valid [out, valid] = rx(); end end","title":"adi.PackRF.Rx"},{"location":"sysobjects/adi.PackRF.Tx/","text":"Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . PackRF . Tx dev = adi . PackRF . Tx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. CenterFrequency + RF center frequency, specified in Hz as a scalar. The default is 2.4e9. This property is tunable.Help for adi.PackRF.Tx/CenterFrequency is inherited from superclass ADI.AD9361.TX SamplingRate + Baseband sampling rate in Hz, specified as a scalar from 65105 to 61.44e6 samples per second.Help for adi.PackRF.Tx/SamplingRate is inherited from superclass ADI.AD9361.TX RFBandwidth + RF Bandwidth of front-end analog filter in Hz, specified as a scalar from 200 kHz to 56 MHz.Help for adi.PackRF.Tx/RFBandwidth is inherited from superclass ADI.AD9361.TX AttenuationChannel0 + Attentuation specified as a scalar from -89.75 to 0 dB with a resolution of 0.25 dB.Help for adi.PackRF.Tx/AttenuationChannel0 is inherited from superclass ADI.AD9361.TX AttenuationChannel1 + Attentuation specified as a scalar from -89.75 to 0 dB with a resolution of 0.25 dB.Help for adi.PackRF.Tx/AttenuationChannel1 is inherited from superclass ADI.AD9361.TX RFPortSelect + 'A' 'B'Help for adi.PackRF.Tx/RFPortSelect is inherited from superclass ADI.AD9361.TX SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance. EnableCustomFilter + Enable use of custom filter file to set SamplingRate, RFBandwidth, and FIR in datapaths CustomFilterFileName + Path to custom filter file created from filter wizard EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.PackRF.Tx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE enIO + If true, connects to libIIO device during simulationHelp for adi.PackRF.Tx/enIO is inherited from superclass MATLABSHARED.LIBIIO.BASE DataSource + Data source, specified as one of the following: 'DMA' \u2014 Specify the host as the source of the data. 'DDS' \u2014 Specify the DDS on the radio hardware as the source of the data. In this case, each channel has two additive tones.Help for adi.PackRF.Tx/DataSource is inherited from superclass ADI.COMMON.DDS DDSFrequencies + Frequencies values in Hz of the DDS tone generators. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.PackRF.Tx/DDSFrequencies is inherited from superclass ADI.COMMON.DDS DDSScales + Scale of DDS tones in range [0,1]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.PackRF.Tx/DDSScales is inherited from superclass ADI.COMMON.DDS DDSPhases + Phases of DDS tones in range [0,360000]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.PackRF.Tx/DDSPhases is inherited from superclass ADI.COMMON.DDS EnableCyclicBuffers + Enable Cyclic Buffers, configures transmit buffers to be cyclic, which makes them continuously repeatHelp for adi.PackRF.Tx/EnableCyclicBuffers is inherited from superclass ADI.COMMON.DDS Example Usage %% Configure device tx = adi.adi.PackRF.Tx; tx.uri = \"ip:analog.local\"; tx.CenterFrequency = 1e9; tx.DataSource = 'DMA'; tx.EnableCyclicBuffers = true; tx.EnabledChannels = 1; %% Generate tone amplitude = 2^15; frequency = 0.12e6; swv1 = dsp.SineWave(amplitude, frequency); swv1.ComplexOutput = true; swv1.SamplesPerFrame = 2^14; swv1.SampleRate = tx.SamplingRate; y = swv1(); % Send tx(y);","title":"adi.PackRF.Tx"},{"location":"sysobjects/adi.Pluto.Rx/","text":"The adi.Pluto.Tx System object is a signal source that can send complex data to the Pluto. tx = adi.Pluto.Tx; tx = adi.Pluto.Tx('uri','ip:192.168.2.1'); Product Page Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . Pluto . Rx dev = adi . Pluto . Rx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. CenterFrequency + RF center frequency, specified in Hz as a scalar. The default is 2.4e9. This property is tunable.Help for adi.Pluto.Rx/CenterFrequency is inherited from superclass ADI.AD9361.RX SamplingRate + Baseband sampling rate in Hz, specified as a scalar from 65105 to 61.44e6 samples per second.Help for adi.Pluto.Rx/SamplingRate is inherited from superclass ADI.AD9361.RX RFBandwidth + RF Bandwidth of front-end analog filter in Hz, specified as a scalar from 200 kHz to 56 MHz.Help for adi.Pluto.Rx/RFBandwidth is inherited from superclass ADI.AD9361.RX GainControlModeChannel0 + specified as one of the following: 'slow_attack' \u2014 For signals with slowly changing power levels 'fast_attack' \u2014 For signals with rapidly changing power levels 'manual' \u2014 For setting the gain manually with the Gain property 'hybrid' \u2014 For configuring hybrid AGC modeHelp for adi.Pluto.Rx/GainControlModeChannel0 is inherited from superclass ADI.AD9361.RX GainChannel0 + Channel 0 gain, specified as a scalar from -3 dB to 71 dB. The acceptable minimum and maximum gain setting depends on the center frequency.Help for adi.Pluto.Rx/GainChannel0 is inherited from superclass ADI.AD9361.RX GainControlModeChannel1 + specified as one of the following: 'slow_attack' \u2014 For signals with slowly changing power levels 'fast_attack' \u2014 For signals with rapidly changing power levels 'manual' \u2014 For setting the gain manually with the Gain property 'hybrid' \u2014 For configuring hybrid AGC modeHelp for adi.Pluto.Rx/GainControlModeChannel1 is inherited from superclass ADI.AD9361.RX GainChannel1 + Channel 1 gain, specified as a scalar from -3 dB to 71 dB. The acceptable minimum and maximum gain setting depends on the center frequency.Help for adi.Pluto.Rx/GainChannel1 is inherited from superclass ADI.AD9361.RX LoopbackMode + Option to set digital loopback mode, specified as 0, 1 or 2. Allows either to digitally loopback TX data into the RX path or vice versa. Value | Mode --------------------------- 0 | Disable 1 | Digital TX -> Digital RX 2 | RF RX -> RF TX Help for adi.Pluto.Rx/LoopbackMode is inherited from superclass ADI.AD9361.RX EnableQuadratureTracking + Option to enable quadrature tracking, specified as true or false. When this property is true, IQ imbalance compensation is applied to the input signal.Help for adi.Pluto.Rx/EnableQuadratureTracking is inherited from superclass ADI.AD9361.RX EnableRFDCTracking + Option to enable RF DC tracking, specified as true or false. When this property is true, an RF DC blocking filter is applied to the input signal.Help for adi.Pluto.Rx/EnableRFDCTracking is inherited from superclass ADI.AD9361.RX EnableBasebandDCTracking + Option to enable baseband DC tracking, specified as true or false. When this property is true, a baseband DC blocking filter is applied to the input signal.Help for adi.Pluto.Rx/EnableBasebandDCTracking is inherited from superclass ADI.AD9361.RX RFPortSelect + 'A_BALANCED' 'B_BALANCED' 'C_BALANCED' 'A_N' 'A_P' 'B_N' 'B_P' 'C_N' 'C_P' 'TX_MONITOR1' 'TX_MONITOR2' 'TX_MONITOR1_2'Help for adi.Pluto.Rx/RFPortSelect is inherited from superclass ADI.AD9361.RX SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance. EnableCustomFilter + Enable use of custom filter file to set SamplingRate, RFBandwidth, and FIR in datapaths CustomFilterFileName + Path to custom filter file created from filter wizard EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.Pluto.Rx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE enIO + If true, connects to libIIO device during simulationHelp for adi.Pluto.Rx/enIO is inherited from superclass MATLABSHARED.LIBIIO.BASE Example Usage %% Rx set up rx = adi.adi.Pluto.Rx.Rx('uri','ip:analog.local'); rx.CenterFrequency = 1e9; rx.EnabledChannels = 1; %% Run for k=1:10 valid = false; while ~valid [out, valid] = rx(); end end","title":"adi.Pluto.Rx"},{"location":"sysobjects/adi.Pluto.Tx/","text":"The adi.Pluto.Tx System object is a signal sink that can transmit complex data from the Pluto. tx = adi.Pluto.Tx; tx = adi.Pluto.Tx('uri','ip:192.168.2.1'); Product Page Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . Pluto . Tx dev = adi . Pluto . Tx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. CenterFrequency + RF center frequency, specified in Hz as a scalar. The default is 2.4e9. This property is tunable.Help for adi.Pluto.Tx/CenterFrequency is inherited from superclass ADI.AD9361.TX SamplingRate + Baseband sampling rate in Hz, specified as a scalar from 65105 to 61.44e6 samples per second.Help for adi.Pluto.Tx/SamplingRate is inherited from superclass ADI.AD9361.TX RFBandwidth + RF Bandwidth of front-end analog filter in Hz, specified as a scalar from 200 kHz to 56 MHz.Help for adi.Pluto.Tx/RFBandwidth is inherited from superclass ADI.AD9361.TX AttenuationChannel0 + Attentuation specified as a scalar from -89.75 to 0 dB with a resolution of 0.25 dB.Help for adi.Pluto.Tx/AttenuationChannel0 is inherited from superclass ADI.AD9361.TX AttenuationChannel1 + Attentuation specified as a scalar from -89.75 to 0 dB with a resolution of 0.25 dB.Help for adi.Pluto.Tx/AttenuationChannel1 is inherited from superclass ADI.AD9361.TX RFPortSelect + 'A' 'B'Help for adi.Pluto.Tx/RFPortSelect is inherited from superclass ADI.AD9361.TX SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance. EnableCustomFilter + Enable use of custom filter file to set SamplingRate, RFBandwidth, and FIR in datapaths CustomFilterFileName + Path to custom filter file created from filter wizard EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.Pluto.Tx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE enIO + If true, connects to libIIO device during simulationHelp for adi.Pluto.Tx/enIO is inherited from superclass MATLABSHARED.LIBIIO.BASE DataSource + Data source, specified as one of the following: 'DMA' \u2014 Specify the host as the source of the data. 'DDS' \u2014 Specify the DDS on the radio hardware as the source of the data. In this case, each channel has two additive tones.Help for adi.Pluto.Tx/DataSource is inherited from superclass ADI.COMMON.DDS DDSFrequencies + Frequencies values in Hz of the DDS tone generators. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.Pluto.Tx/DDSFrequencies is inherited from superclass ADI.COMMON.DDS DDSScales + Scale of DDS tones in range [0,1]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.Pluto.Tx/DDSScales is inherited from superclass ADI.COMMON.DDS DDSPhases + Phases of DDS tones in range [0,360000]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.Pluto.Tx/DDSPhases is inherited from superclass ADI.COMMON.DDS EnableCyclicBuffers + Enable Cyclic Buffers, configures transmit buffers to be cyclic, which makes them continuously repeatHelp for adi.Pluto.Tx/EnableCyclicBuffers is inherited from superclass ADI.COMMON.DDS Example Usage %% Configure device tx = adi.adi.Pluto.Tx; tx.uri = \"ip:analog.local\"; tx.CenterFrequency = 1e9; tx.DataSource = 'DMA'; tx.EnableCyclicBuffers = true; tx.EnabledChannels = 1; %% Generate tone amplitude = 2^15; frequency = 0.12e6; swv1 = dsp.SineWave(amplitude, frequency); swv1.ComplexOutput = true; swv1.SamplesPerFrame = 2^14; swv1.SampleRate = tx.SamplingRate; y = swv1(); % Send tx(y);","title":"adi.Pluto.Tx"},{"location":"sysobjects/output1/","text":"adi.Pluto.Rx Receive data from Analog Devices AD9361 transceiver Description The comm.SDRRxPluto System object\u2122 is a signal source that receives data from an Analog Devices\u00ae ADALM-PLUTO radio. This connection enables you to simulate and develop various software-defined radio applications. The following diagram shows the interaction between MATLAB\u00ae, the comm.SDRRxPluto System object, and the radio hardware. Creation Syntax Properties Unless otherwise indicated, properties are nontunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. CenterFrequency RF center frequency, specified in Hz as a scalar. The default is 2.4e9. This property is tunable.Help for adi.Pluto.Rx/CenterFrequency is inherited from superclass ADI.AD9361.RX SamplingRate Baseband sampling rate in Hz, specified as a scalar from 65105 to 61.44e6 samples per second.Help for adi.Pluto.Rx/SamplingRate is inherited from superclass ADI.AD9361.RX RFBandwidth RF Bandwidth of front-end analog filter in Hz, specified as a scalar from 200 kHz to 56 MHz.Help for adi.Pluto.Rx/RFBandwidth is inherited from superclass ADI.AD9361.RX GainControlModeChannel0 specified as one of the following: 'slow_attack' \u2014 For signals with slowly changing power levels 'fast_attack' \u2014 For signals with rapidly changing power levels 'manual' \u2014 For setting the gain manually with the Gain property 'hybrid' \u2014 For configuring hybrid AGC modeHelp for adi.Pluto.Rx/GainControlModeChannel0 is inherited from superclass ADI.AD9361.RX GainChannel0 Channel 0 gain, specified as a scalar from -3 dB to 71 dB. The acceptable minimum and maximum gain setting depends on the center frequency.Help for adi.Pluto.Rx/GainChannel0 is inherited from superclass ADI.AD9361.RX GainControlModeChannel1 specified as one of the following: 'slow_attack' \u2014 For signals with slowly changing power levels 'fast_attack' \u2014 For signals with rapidly changing power levels 'manual' \u2014 For setting the gain manually with the Gain property 'hybrid' \u2014 For configuring hybrid AGC modeHelp for adi.Pluto.Rx/GainControlModeChannel1 is inherited from superclass ADI.AD9361.RX GainChannel1 Channel 1 gain, specified as a scalar from -3 dB to 71 dB. The acceptable minimum and maximum gain setting depends on the center frequency.Help for adi.Pluto.Rx/GainChannel1 is inherited from superclass ADI.AD9361.RX LoopbackMode Option to set digital loopback mode, specified as 0, 1 or 2. Allows either to digitally loopback TX data into the RX path or vice versa. Value | Mode --------------------------- 0 | Disable 1 | Digital TX -> Digital RX 2 | RF RX -> RF TX Help for adi.Pluto.Rx/LoopbackMode is inherited from superclass ADI.AD9361.RX EnableQuadratureTracking Option to enable quadrature tracking, specified as true or false. When this property is true, IQ imbalance compensation is applied to the input signal.Help for adi.Pluto.Rx/EnableQuadratureTracking is inherited from superclass ADI.AD9361.RX EnableRFDCTracking Option to enable RF DC tracking, specified as true or false. When this property is true, an RF DC blocking filter is applied to the input signal.Help for adi.Pluto.Rx/EnableRFDCTracking is inherited from superclass ADI.AD9361.RX EnableBasebandDCTracking Option to enable baseband DC tracking, specified as true or false. When this property is true, a baseband DC blocking filter is applied to the input signal.Help for adi.Pluto.Rx/EnableBasebandDCTracking is inherited from superclass ADI.AD9361.RX RFPortSelect 'A_BALANCED' 'B_BALANCED' 'C_BALANCED' 'A_N' 'A_P' 'B_N' 'B_P' 'C_N' 'C_P' 'TX_MONITOR1' 'TX_MONITOR2' 'TX_MONITOR1_2'Help for adi.Pluto.Rx/RFPortSelect is inherited from superclass ADI.AD9361.RX SamplesPerFrame Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance. EnableCustomFilter Enable use of custom filter file to set SamplingRate, RFBandwidth, and FIR in datapaths CustomFilterFileName Path to custom filter file created from filter wizard EnabledChannels Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri Hostname or IP address of remote libIIO deviceHelp for adi.Pluto.Rx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE enIO If true, connects to libIIO device during simulationHelp for adi.Pluto.Rx/enIO is inherited from superclass MATLABSHARED.LIBIIO.BASE","title":"Output1"}]}